{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u56db\u5341\u5c81\u6ee1\uff0c \\(\\{0, 1\\}\\) The simplest set represents the difference. 0, 1 are just symbols in the alphabet of size 2. Let 1-bit variable, hold either 0 or 1. Operations on the variable(s) unary: NOT: represents a change, either from 0 to 1, or from 1 to 0. binary: The simplest relationship involves two variables. Let's care about the symmetrical relaitonships only. input Gnd NOR XOR NAND AND XNOR OR Vcc 00 0 1 0 1 0 1 0 1 01/10 0 0 1 1 0 0 1 1 11 0 0 0 0 1 1 1 1 A, b A->B A<-B A<->B 00 1 1 1 01 1 0 0 10 0 1 0 11 1 1 1 With the help of NOT, we can reduce the operations into three: AND OR XOR: \\(F_{SOP} = A\\cdot\\bar{B} + \\bar{A}\\cdot B\\) ; \\(F_{POS} = (A+B)\\cdot(\\bar{A} + \\bar{B})\\) These operations are communitive and associative, so they can apply to multiple variables to form relationship: ALL ANY Truth Table \\(I_{n-1}\\) ... \\(I_1\\) \\(I_0\\) - \\(O_{m-1}\\) ... \\(O_1\\) \\(O_0\\) 0 ... 0 0 - 1 ... 0 1 0 ... 0 1 - 0 ... 1 1 ... ... ... ... - ... ... ... ... 1 ... 1 1 - 1 ... 1 0 Every \\(O_j\\) for \\(j \\in \\{0, 1, \\cdots, m-1\\}\\) , is a function of \\(\\{I_{0},I_{1},\\cdots,I_{n-1}\\}\\) , which can be represented as POS or SOP. Think SOP as any of the possible 1 filters work Think POS as all the 0 filters failed LISP\u63ed\u793a\u4e86\u7a0b\u5e8f\u8bed\u8a00\u7684\u672c\u8d28\uff0cLISP\u7a0b\u5e8f\u672c\u8eab\u5c31\u662f\u4e00\u4e2aAST\u3002\u975e\u53f6\u5b50\u7ed3\u70b9\u4ee3\u8868\u64cd\u4f5c\u7b26\uff0c\u5176\u53f6\u5b50\u7ed3\u70b9\u4ee3\u8868\u64cd\u4f5c\u6570\u3002","title":"Home"},{"location":"#operations-on-the-variables","text":"unary: NOT: represents a change, either from 0 to 1, or from 1 to 0. binary: The simplest relationship involves two variables. Let's care about the symmetrical relaitonships only. input Gnd NOR XOR NAND AND XNOR OR Vcc 00 0 1 0 1 0 1 0 1 01/10 0 0 1 1 0 0 1 1 11 0 0 0 0 1 1 1 1 A, b A->B A<-B A<->B 00 1 1 1 01 1 0 0 10 0 1 0 11 1 1 1 With the help of NOT, we can reduce the operations into three: AND OR XOR: \\(F_{SOP} = A\\cdot\\bar{B} + \\bar{A}\\cdot B\\) ; \\(F_{POS} = (A+B)\\cdot(\\bar{A} + \\bar{B})\\) These operations are communitive and associative, so they can apply to multiple variables to form relationship: ALL ANY","title":"Operations on the variable(s)"},{"location":"#truth-table","text":"\\(I_{n-1}\\) ... \\(I_1\\) \\(I_0\\) - \\(O_{m-1}\\) ... \\(O_1\\) \\(O_0\\) 0 ... 0 0 - 1 ... 0 1 0 ... 0 1 - 0 ... 1 1 ... ... ... ... - ... ... ... ... 1 ... 1 1 - 1 ... 1 0 Every \\(O_j\\) for \\(j \\in \\{0, 1, \\cdots, m-1\\}\\) , is a function of \\(\\{I_{0},I_{1},\\cdots,I_{n-1}\\}\\) , which can be represented as POS or SOP. Think SOP as any of the possible 1 filters work Think POS as all the 0 filters failed","title":"Truth Table"},{"location":"#_1","text":"LISP\u63ed\u793a\u4e86\u7a0b\u5e8f\u8bed\u8a00\u7684\u672c\u8d28\uff0cLISP\u7a0b\u5e8f\u672c\u8eab\u5c31\u662f\u4e00\u4e2aAST\u3002\u975e\u53f6\u5b50\u7ed3\u70b9\u4ee3\u8868\u64cd\u4f5c\u7b26\uff0c\u5176\u53f6\u5b50\u7ed3\u70b9\u4ee3\u8868\u64cd\u4f5c\u6570\u3002","title":""},{"location":"bayes/","text":"Bayes Theorem \u89e3\u51b3\u4ec0\u4e48\u95ee\u9898 \u663e\u793a\u4e3a\u9633\u6027\u7684\u6d4b\u8bd5\u7ed3\u679c\u6709\u591a\u53ef\u9760\uff1f \u53ef\u9760\u6027\u7406\u89e3\u4e3a\u5f53\u6d4b\u8bd5\u7ed3\u679c\u663e\u793a\u4e3aPositive\u65f6\uff0c\u4e8b\u5b9e\u4e0e\u6d4b\u8bd5\u7ed3\u679c\u4e00\u81f4\u7684\u6982\u7387\u3002\u5373\uff0c\u5927\u91cf\u663e\u793aPositive\u7ed3\u679c\u7684\u6d4b\u8bd5\u4e2d\uff0c\u4e8b\u5b9e\u4e3aPositive\u7684\u6bd4\u4f8b\u3002 \u6ce8\u610f\u8ddf\u6d4b\u8bd5\u7ed3\u679c\u4e3aNegative\u65f6\u7684\u53ef\u9760\u6027\u662f\u4e24\u4e2a\u4e0d\u4e00\u6837\u7684\u6982\u5ff5\uff01 \u7406\u89e3 \u5e94\u7528 \u56e0\u679c \u56e0\u679c\u89e3\u8bfb\uff0c\u8ba4\u4e3a\u4e00\u4e2a\u4e8b\u4ef6\u5728\u65f6\u95f4\u4e0a\uff0c\u6709\u5f15\u5165\u53e6\u5916\u4e00\u4e2a\u540e\u7eed\u4e8b\u4ef6\u7684\u903b\u8f91\u3002\u524d\u8005\u4e3a\u56e0\uff0c\u540e\u8005\u4e3a\u679c\u3002 \u4f46\u662f\u5728\u8fd9\u4e2a\u516c\u5f0f\u91cc\uff0c\u56e0\u679c\u53ea\u662f\u4e00\u4e2a\u65b9\u4fbf\u7684\u7406\u89e3\u5de5\u5177\uff0c\u4e24\u4e2a\u4e8b\u4ef6\u4e0d\u9700\u8981\u5177\u6709\u76f4\u89c9\u4e0a\u7684\u56e0\u679c\u5173\u7cfb\u3002 False Positive\u6240\u626e\u6f14\u7684\u89d2\u8272 \\[\\frac{X}{X + FP}\\]","title":"Bayes"},{"location":"bayes/#bayes-theorem","text":"","title":"Bayes Theorem"},{"location":"bayes/#_1","text":"\u663e\u793a\u4e3a\u9633\u6027\u7684\u6d4b\u8bd5\u7ed3\u679c\u6709\u591a\u53ef\u9760\uff1f \u53ef\u9760\u6027\u7406\u89e3\u4e3a\u5f53\u6d4b\u8bd5\u7ed3\u679c\u663e\u793a\u4e3aPositive\u65f6\uff0c\u4e8b\u5b9e\u4e0e\u6d4b\u8bd5\u7ed3\u679c\u4e00\u81f4\u7684\u6982\u7387\u3002\u5373\uff0c\u5927\u91cf\u663e\u793aPositive\u7ed3\u679c\u7684\u6d4b\u8bd5\u4e2d\uff0c\u4e8b\u5b9e\u4e3aPositive\u7684\u6bd4\u4f8b\u3002 \u6ce8\u610f\u8ddf\u6d4b\u8bd5\u7ed3\u679c\u4e3aNegative\u65f6\u7684\u53ef\u9760\u6027\u662f\u4e24\u4e2a\u4e0d\u4e00\u6837\u7684\u6982\u5ff5\uff01","title":"\u89e3\u51b3\u4ec0\u4e48\u95ee\u9898"},{"location":"bayes/#_2","text":"","title":"\u7406\u89e3"},{"location":"bayes/#_3","text":"","title":"\u5e94\u7528"},{"location":"bayes/#_4","text":"\u56e0\u679c\u89e3\u8bfb\uff0c\u8ba4\u4e3a\u4e00\u4e2a\u4e8b\u4ef6\u5728\u65f6\u95f4\u4e0a\uff0c\u6709\u5f15\u5165\u53e6\u5916\u4e00\u4e2a\u540e\u7eed\u4e8b\u4ef6\u7684\u903b\u8f91\u3002\u524d\u8005\u4e3a\u56e0\uff0c\u540e\u8005\u4e3a\u679c\u3002 \u4f46\u662f\u5728\u8fd9\u4e2a\u516c\u5f0f\u91cc\uff0c\u56e0\u679c\u53ea\u662f\u4e00\u4e2a\u65b9\u4fbf\u7684\u7406\u89e3\u5de5\u5177\uff0c\u4e24\u4e2a\u4e8b\u4ef6\u4e0d\u9700\u8981\u5177\u6709\u76f4\u89c9\u4e0a\u7684\u56e0\u679c\u5173\u7cfb\u3002","title":"\u56e0\u679c"},{"location":"bayes/#false-positive","text":"\\[\\frac{X}{X + FP}\\]","title":"False Positive\u6240\u626e\u6f14\u7684\u89d2\u8272"},{"location":"ca.sfu.cmpt379.2022.fall/","text":"\u9879\u76ee\u57fa\u672c\u7ed3\u6784 \u8bfe\u7a0b\u9879\u76ee\u6846\u67b6\u6309\u7167\u529f\u80fd\u9636\u6bb5\u7ec4\u7ec7\u5982\u4e0b\uff1a logging \u8fd9\u4e2a\u88ab\u7528\u6765\u62a5\u9519\uff0c\u611f\u89c9\u8fd8\u662f\u6709\u70b9\u4e0d\u5bf9\u52b2 inputHandler \u5f15\u5165\u63a5\u53e3Locator \u5c06\u8f93\u5165\u6587\u4ef6\u5c01\u88c5\u6210\u53ef\u5b9a\u4f4d\u7684\u53ef\u56de\u9000\u7684\u5b57\u7b26\u6d41\uff0c\u65b9\u4fbflexicalAnalyzer\u63d0\u53d6token lexicalAnalyzer \u672c\u8d28\u4e0a\u662f\u4e00\u4e2atoken iterator lextant: \u8bcd\u6cd5\u5355\u5143\u4e2d\u7684\u6807\u70b9\u7b26\u53f7\u4ee5\u53ca\u5173\u952e\u5b57 tokens \u57fa\u672c\u62bd\u8c61token\uff1a\u53ef\u5b9a\u4f4d\uff0c\u53ef\u83b7\u53d6\u8bcd\u7d20 \u8bcd\u7d20 \u5b9a\u4f4d \u662f\u5426\u5c5e\u4e8elextant set \u5b57\u9762\u91cf\uff1a\u6574\u578b\uff0c\u6d6e\u70b9\uff0c\u5b57\u7b26\uff0c\u5e03\u5c14\u503c\uff0c\u5b57\u7b26\u4e32 \u6807\u8bc6\u7b26 \u6807\u70b9 \u5173\u952e\u5b57 parser \u8bfb\u53d6token\u6d41\uff0c\u901a\u8fc7BNF\u4ea7\u751f\u5f0f\u6784\u9020AST parseTree \u63d0\u4f9b\u57fa\u672c\u7c7bParseNode getClass() getToken() getType() getScope() \u63d0\u4f9b\u57fa\u672c\u7c7bParseNodeVisitor parseTree.nodeTypes \u975e\u7ec8\u7ed3\u7b26\u5bf9\u5e94\u7684\u5404\u79cd\u5177\u4f53\u7684Node sementicAnalyzer \u5bf9AST\u8fdb\u884c\u8bed\u4e49\u5206\u6790\uff0c\u68c0\u67e5\u63a8\u65ad\u7c7b\u578b\uff0c\u5206\u914d\u5185\u5b58\uff0c\u6784\u5efa\u7ed1\u5b9a sementicAnalyzer.types \u7c7b\u578b\u7cfb\u7edf sementicAnalyzer.signatures \u6839\u636e\u8f93\u5165\u7684\u7c7b\u578b\u9009\u62e9\u5408\u6cd5\u7684\u64cd\u4f5c symbolTable MemoryLocation baseAddress:String; \u5185\u5b58\u5b9a\u4f4d\u603b\u662f\u57fa\u4e8e\u67d0\u4e2a\u57fa\u5730\u5740\uff0c\u53ef\u4ee5\u662f\u5185\u5b58\u7684\u67d0\u4e2a\u6bb5\uff0c\u6216\u8005\u901a\u8fc7\u201c\u5bc4\u5b58\u5668\u201d\u95f4\u63a5\u5bfb\u5740\u3002\u8fd9\u4e2a\u673a\u5668\u91cc\u6ca1\u6709\u5bc4\u5b58\u5668\u7684\u6982\u5ff5\uff0c\u4f46\u662f\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u9884\u7559\u7684\u5168\u5c40\u7a7a\u95f4\u6765\u6a21\u62df\u3002\u6bd4\u5982FP,SP\u7684\u5b9e\u73b0\u3002 offset:int \u56e0\u4e3a\u5206\u914d\u5185\u5b58\u7684\u65f6\u5019\uff0c\u5e76\u6ca1\u6709\u5b8c\u5168\u786e\u5b9a\u4e0b\u6765\u6700\u540e\u7684\u4f4d\u7f6e\u3002\u6240\u4ee5\u5206\u914d\u7684\u5185\u5b58\u4fe1\u606f\u5305\u542b\u4e86\u76f8\u5bf9\u7684\u504f\u79fb\u503c\u3002 MemoryAccessMethod \u8fd9\u4e2a\u7c7b\u4ee5enum\u7684\u5f62\u5f0f\u63d0\u4f9b\u4e862\u4e2a\u5185\u5b58\u8bbf\u95ee\u65b9\u6cd5\uff0c\u5206\u522b\u662f\u57fa\u4e8e\u7b26\u53f7\u7684\u76f4\u63a5\u504f\u79fb\u5bfb\u5740\uff0c\u4ee5\u53ca\u95f4\u63a5\u5bfb\u5740\u3002base[offset], base[0][offset] \u8fd9\u4e2a\u95f4\u63a5\u5bfb\u5740\u7b49\u4ef7\u4e8e\u901a\u8fc7\u5bc4\u5b58\u5668\u5bfb\u5740\uff0c\u7528\u4e00\u4e2a\u9884\u5148\u5206\u914d\u7684\u56fa\u5b9a\u5185\u5b58\u4f4d\u7f6e\u5145\u5f53\u5bc4\u5b58\u5668\u3002 design pattern: template method, Java enum singleton public void generateAddress(ASMCodeFragment code, String baseAddress, int offset, String comment) \u5f80code\u91cc\u52a0\u5165\u53d8\u91cf\u7684\u5730\u5740\uff0c\u5e76\u52a0\u4ee5\u6807\u6ce8 \u57fa\u5730\u5740\uff0coffset\uff0c\u4ee5\u53ca\u6807\u6ce8\uff08\u540d\u5b57\uff09\u6765\u81ea\u7ed1\u5b9a\u7684memoryLocation \u8fd9\u4e2a\u7c7b\u5176\u5b9e\u5e94\u8be5\u653e\u5728code generator\u91cc \u57fa\u672c\u62bd\u8c61Scope \u6bcf\u4e2ascope\u6709\u4e00\u4e2a\u5185\u5b58\u5206\u914d\u5668MemoryAllocator\uff08subscope\u7ee7\u627f\u8fd9\u4e2a\u5206\u914d\u5668\uff09 MemoryAllocator\uff08\u7ba1\u7406\u5bfb\u5740\u65b9\u5f0f\uff0c\u57fa\u5740\uff0c\u5206\u914d\u65b9\u5411\uff09 \u63a5\u53d7\u7ed9\u5b9a\u5927\u5c0f\u7684\u5206\u914d\u8bf7\u6c42\uff0c\u8fd4\u56deMemoryLocation MemoryLocation\u63d0\u4f9b\u751f\u6210\u538b\u6808\u5730\u5740\u7684\u6307\u4ee4\u5e8f\u5217 \u6bcf\u4e2aScope\u7ef4\u62a4\u81ea\u5df1\u7684\u7b26\u53f7\u8868SymbolTable(String -> Binding) nullInstance()\u8fd9\u4e2a\u5176\u5b9e\u6ca1\u6709\u5b58\u5728\u7684\u5fc5\u8981\u3002\u552f\u4e00\u7528\u5230\u7684\u5730\u65b9\u5176\u5b9e\u662f\u6b7b\u4ee3\u7801 getAllocatedSize() \u6bcf\u6b21\u521b\u5efascope\u65f6\uff0c\u5bf9\u5e94\u7684\u5206\u914d\u5668\u505a\u4e00\u6b21\u6807\u8bb0\uff0c\u79bb\u5f00\u8fd9\u4e2ascope\u7684\u65f6\u5019\uff0c\u5206\u914d\u5668\u5f39\u51fa\u4e0a\u4e00\u4e2a\u8bb0\u5f55 SymbolTable\u672c\u8d28\u4e0a\u5c31\u662f\u6807\u8bc6\u7b26\u5230\u7ed1\u5b9a\u7684\u6620\u5c04 Binding: \u6807\u8bc6\u7b26\u540d\u79f0\uff0c\u7c7b\u578b\uff0c\u6e90\u6587\u4ef6\u4f4d\u7f6e\uff0c\u5185\u5b58\u4f4d\u7f6e\uff0c\u7b49\u76f8\u5173\u7684\u4fe1\u606f\u3002\u6bcf\u4e2a\u5206\u914d\u4e86\u5185\u5b58\u5730\u5740\u7684binding\uff0c\u90fd\u5e94\u8be5\u6709\u4e00\u4e2amemoryLocation\uff0c\u5e76\u4e14\u53ef\u4ee5\u6839\u636e\u8fd9\u4e2a\u5185\u5b58\u5730\u5740\u6765\u751f\u6210\u4ee3\u7801\u5c06\u6b64\u4ee3\u7801\u538b\u6808\u3002binding.memoryLocation.getAddressCode()\uff0c\u6216\u8005CodeGenerator.generateAddressCode(binding.memoryLocation)\u3002\u54ea\u79cd\u8bbe\u8ba1\u66f4\u597d\uff1f\u4e3a\u4ec0\u4e48\uff1f asmCodeGenerator \u4ea7\u751f\u7ebf\u6027\u7684\u4ee3\u7801\u7ed3\u6784 asmCodeGenerator.codeStorage \u6307\u4ee4\uff0c\u6307\u4ee4\u5757 asmCodeGenerator.operators asmCodeGenerator.runtime \u8fd0\u884c\u65f6\u652f\u6301 \u5185\u5b58\u5206\u914d\u5668 \u8fd0\u884c\u65f6\u51fd\u6570 \u4e00\u4e9b\u7b14\u8bb0\uff0c\u4ee5\u514d\u9057\u5fd8 Binding\u662f\u5728\u54ea\u91cc\u6784\u9020\u7684 \u8bed\u4e49\u5206\u6790\u65f6\uff0c\u9047\u5230\u58f0\u660e\u8bed\u53e5\u65f6\uff0c\u56e0\u4e3a\u5df2\u7ecf\u5904\u7406\u8fc7\u6807\u8bc6\u7b26\u8282\u70b9\uff0c\u4ee5\u53ca\u8868\u8fbe\u5f0f\u8282\u70b9\u3002\u53ef\u4ee5\u5728\u9000\u51fa\u8bbf\u95ee\u58f0\u660e\u8bed\u53e5\u8282\u70b9\u65f6\u6784\u5efa\u7ed1\u5b9a\u3002 SemanticAnalyzer IdentifierNode Scope CreateBinding \u8bed\u4e49\u5206\u6790\u65f6\uff0c\u83b7\u53d6\u4e86\u7c7b\u578b\u4fe1\u606f\u5c31\u76f4\u63a5\u5206\u914d\u5185\u5b58\u5e76\u751f\u6210\u7ed1\u5b9a\u5e76\u4f20\u9012\u7ed9IdentifierNode Binding\u6838\u5fc3\u529f\u80fd\u5c31\u662f\u63d0\u4f9b\u7c7b\u578b\u548c\u5185\u5b58\u5730\u5740 IdentifierNode\u662f\u53f6\u5b50\u7ed3\u70b9\uff0c\u6240\u4ee5\u4f7f\u7528visit\u3002\u8bed\u4e49\u5206\u6790\u8bbf\u95ee\u5c5e\u4e8eDeclarationNode\u7684\u6b64\u7ed3\u70b9\u65f6\u751f\u6210Binding\uff0c\u4ee3\u7801\u751f\u6210\u5668\u8bbf\u95ee\u65f6\u6b64\u7ed3\u70b9\u65f6\u751f\u6210\u5730\u5740\u3002 MemoryManager.java\u662f\u4e00\u4e2a\u5806\u7684\u5206\u914d\u5668\uff0c\u8fd9\u91cc\u7684\u51fd\u6570\u90fd\u4f7f\u7528\u5168\u5c40\u53d8\u91cf\uff0c\u56e0\u6b64\u4e0d\u80fd\u9012\u5f52\u8c03\u7528\u3002\u5176\u5b9e\u4e0e\u5176\u53eb\u5b83\u4eec\u51fd\u6570\uff0c\u4e0d\u5982\u53ebroutine/procedure\u66f4\u5408\u9002\uff0c\u56e0\u4e3a\u5b83\u4eec\u6ca1\u6709\u81ea\u5df1\u7684\u5c40\u90e8\u53d8\u91cf\u3002 \u51fd\u6570\u8c03\u7528\u5e94\u8be5\u751f\u6210\u4e00\u4e2a\u503c\uff0c\u5373\u4f7f\u8fd9\u4e2a\u51fd\u6570\u662fvoid\uff0c\u4ee3\u7801\u751f\u6210\u4e5f\u662f\u4e00\u4e2aValueCode AtomicExpression\u7b49\u540c\u4e8eC\u91cc\u7684PrimaryExpression\uff0c\u5373\u6700\u9ad8\u4f18\u5148\u7ea7\u7684\u8868\u8fbe\u5f0f\uff0c\u8868\u8fbe\u5f0f\u6700\u9ad8\u4f18\u5148\u7ea7\u603b\u662f\u4f1a\u6536\u655b\u5230\u6b64\u3002 \u9519\u8bef\u5904\u7406\uff0c\u8bed\u6cd5\uff0c\u8fd4\u56de\u4e00\u4e2aErrorNode\uff0c\u8bed\u4e49\u8d4b\u503c\u4e00\u4e2aErrorTYpe\uff0c\u4ee3\u7801\u751f\u6210\u62d2\u7edd\u3002 Bilby\u53ea\u6709\u5168\u5c40\uff08\u9759\u6001\uff09\u4f5c\u7528\u57df\uff0c\u51fd\u6570\u4f5c\u7528\u57df\uff0c\u53d8\u91cf\u5bfb\u5740\u5c31\u76f8\u5f53\u5bb9\u6613\u3002 \u6240\u6709\u7684string\u5b57\u9762\u91cf\u90fd\u53ef\u4ee5\u653e\u5728global\u4e0b\u3002 \u5de6\u503c\u4ee5\u5730\u5740\u7684\u5f62\u5f0f\u51fa\u73b0\u5728\u8d4b\u503c\u64cd\u4f5c\u5de6\u4fa7\uff0c\u5176\u4ed6\u5730\u65b9\u90fd\u8f6c\u6210\u6240\u5305\u542b\u7684\u6570\u503c\u3002 \u7b97\u7b26\u7684\u7c7b\u578b\u662f\u6240\u652f\u6301\u7684signature\u7684\u96c6\u5408\u3002 \u5982\u679c\u51fd\u6570\u652f\u6301\u91cd\u8f7d\uff0c\u90a3\u4e48\u5b83\u7684\u7c7b\u578b\u4e5f\u662fsignature\u7684\u96c6\u5408\uff0c\uff08\u5339\u914d\u53c2\u6570\u7684\u65f6\u5019\uff0c\u53ea\u5173\u5fc3\u53c2\u6570\u7c7b\u578b\uff0c\u6240\u4ee5\u4e0d\u540c\u7684\u8fd4\u56de\u7c7b\u578b\u4e0d\u80fd\u4f5c\u4e3a\u4e0d\u540csignature\u7684\u5224\u65ad\u4f9d\u636e\uff09 \u4efb\u52a1\u5206\u89e3 \u5806\u5206\u914d\u5668\u7684\u8fd0\u884c\u65f6\u903b\u8f91 \u5173\u4e8e\u52a8\u6001\u4f5c\u7528\u57df\u8ddf\u9759\u6001\u4f5c\u7528\u57df a = 1 foo(): return a + 3 main(): a = 2 b = foo() if (b == 5) dynamic else if (b == 4) static Design Patterns parseTree.PathToRootIterable size of the skeleton project engineer@mac bilby-S % find . -name '*.java' | grep 'tests' -v | xargs wc -l | sort -hr 5876 total 785 ./src/asmCodeGenerator/runtime/MemoryManager.java 404 ./src/parser/Parser.java 319 ./src/asmCodeGenerator/ASMCodeGenerator.java 188 ./src/asmCodeGenerator/codeStorage/ASMCodeFragment.java 171 ./src/semanticAnalyzer/SemanticAnalysisVisitor.java 170 ./src/asmCodeGenerator/codeStorage/ASMOpcode.java 167 ./src/lexicalAnalyzer/LexicalAnalyzer.java 166 ./src/parseTree/ParseNode.java 158 ./src/asmCodeGenerator/codeStorage/ASMInstruction.java 124 ./src/symbolTable/Scope.java 121 ./src/parseTree/ParseTreePrinter.java 118 ./src/parseTree/ParseNodeVisitor.java 109 ./src/semanticAnalyzer/signatures/FunctionSignature.java 108 ./src/lexicalAnalyzer/PunctuatorScanningAids.java 105 ./src/asmCodeGenerator/Macros.java 96 ./src/semanticAnalyzer/signatures/FunctionSignatures.java 92 ./src/asmCodeGenerator/runtime/RunTime.java 91 ./src/applications/BilbyApplication.java 88 ./src/inputHandler/InputHandler.java 87 ./src/applications/BilbyCompiler.java 86 ./src/applications/BilbyCodeGenerator.java 85 ./src/inputHandler/LocatedCharStream.java 78 ./src/asmCodeGenerator/PrintStatementGenerator.java 77 ./src/parseTree/nodeTypes/IdentifierNode.java 77 ./src/inputHandler/LineBasedReader.java 68 ./src/symbolTable/SymbolTable.java 66 ./src/symbolTable/Binding.java 65 ./src/logging/BilbyLogger.java 62 ./src/inputHandler/LocatedChar.java 61 ./src/lexicalAnalyzer/PunctuatorScanner.java 61 ./src/inputHandler/TextLocation.java 59 ./src/symbolTable/MemoryLocation.java 58 ./src/symbolTable/NegativeMemoryAllocator.java 58 ./src/asmCodeGenerator/codeStorage/ASMCodeChunk.java 57 ./src/symbolTable/PositiveMemoryAllocator.java 56 ./src/lexicalAnalyzer/Punctuator.java 52 ./src/parseTree/nodeTypes/DeclarationNode.java 51 ./src/tokens/TokenImp.java 50 ./src/parseTree/nodeTypes/OperatorNode.java 49 ./src/lexicalAnalyzer/Keyword.java 49 ./src/inputHandler/PushbackCharStream.java 46 ./src/inputHandler/LocatedCharString.java 43 ./src/symbolTable/MemoryAccessMethod.java 43 ./src/applications/BilbyTokenPrinter.java 42 ./src/applications/BilbySemanticChecker.java 39 ./src/parseTree/PathToRootIterable.java 38 ./src/applications/BilbyAbstractSyntaxTree.java 36 ./src/parseTree/nodeTypes/BooleanConstantNode.java 36 ./src/applications/NumberedFileLister.java 35 ./src/parseTree/nodeTypes/IntegerConstantNode.java 35 ./src/lexicalAnalyzer/ScannerImp.java 33 ./src/tokens/LextantToken.java 33 ./src/parseTree/nodeTypes/PrintStatementNode.java 32 ./src/lexicalAnalyzer/PartiallyScannedPunctuator.java 31 ./src/tokens/Tokens.java 28 ./src/tokens/NumberToken.java 28 ./src/parseTree/nodeTypes/ProgramNode.java 28 ./src/parseTree/nodeTypes/MainBlockNode.java 27 ./src/semanticAnalyzer/types/PrimitiveType.java 25 ./src/lexicalAnalyzer/LexemeMap.java 23 ./src/parseTree/nodeTypes/SpaceNode.java 23 ./src/parseTree/nodeTypes/NewlineNode.java 23 ./src/parseTree/nodeTypes/ErrorNode.java 22 ./src/semanticAnalyzer/SemanticAnalyzer.java 21 ./src/asmCodeGenerator/Labeller.java 20 ./src/tokens/NullToken.java 20 ./src/tokens/IdentifierToken.java 17 ./src/semanticAnalyzer/types/Type.java 13 ./src/tokens/Token.java 11 ./src/symbolTable/MemoryAllocator.java 11 ./src/asmCodeGenerator/operators/SimpleCodeGenerator.java 9 ./src/lexicalAnalyzer/Scanner.java 8 ./src/lexicalAnalyzer/Lextant.java 5 ./src/inputHandler/Locator.java","title":"ca.sfu.cmpt379.2022.fall"},{"location":"ca.sfu.cmpt379.2022.fall/#_1","text":"\u8bfe\u7a0b\u9879\u76ee\u6846\u67b6\u6309\u7167\u529f\u80fd\u9636\u6bb5\u7ec4\u7ec7\u5982\u4e0b\uff1a logging \u8fd9\u4e2a\u88ab\u7528\u6765\u62a5\u9519\uff0c\u611f\u89c9\u8fd8\u662f\u6709\u70b9\u4e0d\u5bf9\u52b2 inputHandler \u5f15\u5165\u63a5\u53e3Locator \u5c06\u8f93\u5165\u6587\u4ef6\u5c01\u88c5\u6210\u53ef\u5b9a\u4f4d\u7684\u53ef\u56de\u9000\u7684\u5b57\u7b26\u6d41\uff0c\u65b9\u4fbflexicalAnalyzer\u63d0\u53d6token lexicalAnalyzer \u672c\u8d28\u4e0a\u662f\u4e00\u4e2atoken iterator lextant: \u8bcd\u6cd5\u5355\u5143\u4e2d\u7684\u6807\u70b9\u7b26\u53f7\u4ee5\u53ca\u5173\u952e\u5b57 tokens \u57fa\u672c\u62bd\u8c61token\uff1a\u53ef\u5b9a\u4f4d\uff0c\u53ef\u83b7\u53d6\u8bcd\u7d20 \u8bcd\u7d20 \u5b9a\u4f4d \u662f\u5426\u5c5e\u4e8elextant set \u5b57\u9762\u91cf\uff1a\u6574\u578b\uff0c\u6d6e\u70b9\uff0c\u5b57\u7b26\uff0c\u5e03\u5c14\u503c\uff0c\u5b57\u7b26\u4e32 \u6807\u8bc6\u7b26 \u6807\u70b9 \u5173\u952e\u5b57 parser \u8bfb\u53d6token\u6d41\uff0c\u901a\u8fc7BNF\u4ea7\u751f\u5f0f\u6784\u9020AST parseTree \u63d0\u4f9b\u57fa\u672c\u7c7bParseNode getClass() getToken() getType() getScope() \u63d0\u4f9b\u57fa\u672c\u7c7bParseNodeVisitor parseTree.nodeTypes \u975e\u7ec8\u7ed3\u7b26\u5bf9\u5e94\u7684\u5404\u79cd\u5177\u4f53\u7684Node sementicAnalyzer \u5bf9AST\u8fdb\u884c\u8bed\u4e49\u5206\u6790\uff0c\u68c0\u67e5\u63a8\u65ad\u7c7b\u578b\uff0c\u5206\u914d\u5185\u5b58\uff0c\u6784\u5efa\u7ed1\u5b9a sementicAnalyzer.types \u7c7b\u578b\u7cfb\u7edf sementicAnalyzer.signatures \u6839\u636e\u8f93\u5165\u7684\u7c7b\u578b\u9009\u62e9\u5408\u6cd5\u7684\u64cd\u4f5c symbolTable MemoryLocation baseAddress:String; \u5185\u5b58\u5b9a\u4f4d\u603b\u662f\u57fa\u4e8e\u67d0\u4e2a\u57fa\u5730\u5740\uff0c\u53ef\u4ee5\u662f\u5185\u5b58\u7684\u67d0\u4e2a\u6bb5\uff0c\u6216\u8005\u901a\u8fc7\u201c\u5bc4\u5b58\u5668\u201d\u95f4\u63a5\u5bfb\u5740\u3002\u8fd9\u4e2a\u673a\u5668\u91cc\u6ca1\u6709\u5bc4\u5b58\u5668\u7684\u6982\u5ff5\uff0c\u4f46\u662f\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u9884\u7559\u7684\u5168\u5c40\u7a7a\u95f4\u6765\u6a21\u62df\u3002\u6bd4\u5982FP,SP\u7684\u5b9e\u73b0\u3002 offset:int \u56e0\u4e3a\u5206\u914d\u5185\u5b58\u7684\u65f6\u5019\uff0c\u5e76\u6ca1\u6709\u5b8c\u5168\u786e\u5b9a\u4e0b\u6765\u6700\u540e\u7684\u4f4d\u7f6e\u3002\u6240\u4ee5\u5206\u914d\u7684\u5185\u5b58\u4fe1\u606f\u5305\u542b\u4e86\u76f8\u5bf9\u7684\u504f\u79fb\u503c\u3002 MemoryAccessMethod \u8fd9\u4e2a\u7c7b\u4ee5enum\u7684\u5f62\u5f0f\u63d0\u4f9b\u4e862\u4e2a\u5185\u5b58\u8bbf\u95ee\u65b9\u6cd5\uff0c\u5206\u522b\u662f\u57fa\u4e8e\u7b26\u53f7\u7684\u76f4\u63a5\u504f\u79fb\u5bfb\u5740\uff0c\u4ee5\u53ca\u95f4\u63a5\u5bfb\u5740\u3002base[offset], base[0][offset] \u8fd9\u4e2a\u95f4\u63a5\u5bfb\u5740\u7b49\u4ef7\u4e8e\u901a\u8fc7\u5bc4\u5b58\u5668\u5bfb\u5740\uff0c\u7528\u4e00\u4e2a\u9884\u5148\u5206\u914d\u7684\u56fa\u5b9a\u5185\u5b58\u4f4d\u7f6e\u5145\u5f53\u5bc4\u5b58\u5668\u3002 design pattern: template method, Java enum singleton public void generateAddress(ASMCodeFragment code, String baseAddress, int offset, String comment) \u5f80code\u91cc\u52a0\u5165\u53d8\u91cf\u7684\u5730\u5740\uff0c\u5e76\u52a0\u4ee5\u6807\u6ce8 \u57fa\u5730\u5740\uff0coffset\uff0c\u4ee5\u53ca\u6807\u6ce8\uff08\u540d\u5b57\uff09\u6765\u81ea\u7ed1\u5b9a\u7684memoryLocation \u8fd9\u4e2a\u7c7b\u5176\u5b9e\u5e94\u8be5\u653e\u5728code generator\u91cc \u57fa\u672c\u62bd\u8c61Scope \u6bcf\u4e2ascope\u6709\u4e00\u4e2a\u5185\u5b58\u5206\u914d\u5668MemoryAllocator\uff08subscope\u7ee7\u627f\u8fd9\u4e2a\u5206\u914d\u5668\uff09 MemoryAllocator\uff08\u7ba1\u7406\u5bfb\u5740\u65b9\u5f0f\uff0c\u57fa\u5740\uff0c\u5206\u914d\u65b9\u5411\uff09 \u63a5\u53d7\u7ed9\u5b9a\u5927\u5c0f\u7684\u5206\u914d\u8bf7\u6c42\uff0c\u8fd4\u56deMemoryLocation MemoryLocation\u63d0\u4f9b\u751f\u6210\u538b\u6808\u5730\u5740\u7684\u6307\u4ee4\u5e8f\u5217 \u6bcf\u4e2aScope\u7ef4\u62a4\u81ea\u5df1\u7684\u7b26\u53f7\u8868SymbolTable(String -> Binding) nullInstance()\u8fd9\u4e2a\u5176\u5b9e\u6ca1\u6709\u5b58\u5728\u7684\u5fc5\u8981\u3002\u552f\u4e00\u7528\u5230\u7684\u5730\u65b9\u5176\u5b9e\u662f\u6b7b\u4ee3\u7801 getAllocatedSize() \u6bcf\u6b21\u521b\u5efascope\u65f6\uff0c\u5bf9\u5e94\u7684\u5206\u914d\u5668\u505a\u4e00\u6b21\u6807\u8bb0\uff0c\u79bb\u5f00\u8fd9\u4e2ascope\u7684\u65f6\u5019\uff0c\u5206\u914d\u5668\u5f39\u51fa\u4e0a\u4e00\u4e2a\u8bb0\u5f55 SymbolTable\u672c\u8d28\u4e0a\u5c31\u662f\u6807\u8bc6\u7b26\u5230\u7ed1\u5b9a\u7684\u6620\u5c04 Binding: \u6807\u8bc6\u7b26\u540d\u79f0\uff0c\u7c7b\u578b\uff0c\u6e90\u6587\u4ef6\u4f4d\u7f6e\uff0c\u5185\u5b58\u4f4d\u7f6e\uff0c\u7b49\u76f8\u5173\u7684\u4fe1\u606f\u3002\u6bcf\u4e2a\u5206\u914d\u4e86\u5185\u5b58\u5730\u5740\u7684binding\uff0c\u90fd\u5e94\u8be5\u6709\u4e00\u4e2amemoryLocation\uff0c\u5e76\u4e14\u53ef\u4ee5\u6839\u636e\u8fd9\u4e2a\u5185\u5b58\u5730\u5740\u6765\u751f\u6210\u4ee3\u7801\u5c06\u6b64\u4ee3\u7801\u538b\u6808\u3002binding.memoryLocation.getAddressCode()\uff0c\u6216\u8005CodeGenerator.generateAddressCode(binding.memoryLocation)\u3002\u54ea\u79cd\u8bbe\u8ba1\u66f4\u597d\uff1f\u4e3a\u4ec0\u4e48\uff1f asmCodeGenerator \u4ea7\u751f\u7ebf\u6027\u7684\u4ee3\u7801\u7ed3\u6784 asmCodeGenerator.codeStorage \u6307\u4ee4\uff0c\u6307\u4ee4\u5757 asmCodeGenerator.operators asmCodeGenerator.runtime \u8fd0\u884c\u65f6\u652f\u6301 \u5185\u5b58\u5206\u914d\u5668 \u8fd0\u884c\u65f6\u51fd\u6570","title":"\u9879\u76ee\u57fa\u672c\u7ed3\u6784"},{"location":"ca.sfu.cmpt379.2022.fall/#_2","text":"Binding\u662f\u5728\u54ea\u91cc\u6784\u9020\u7684 \u8bed\u4e49\u5206\u6790\u65f6\uff0c\u9047\u5230\u58f0\u660e\u8bed\u53e5\u65f6\uff0c\u56e0\u4e3a\u5df2\u7ecf\u5904\u7406\u8fc7\u6807\u8bc6\u7b26\u8282\u70b9\uff0c\u4ee5\u53ca\u8868\u8fbe\u5f0f\u8282\u70b9\u3002\u53ef\u4ee5\u5728\u9000\u51fa\u8bbf\u95ee\u58f0\u660e\u8bed\u53e5\u8282\u70b9\u65f6\u6784\u5efa\u7ed1\u5b9a\u3002 SemanticAnalyzer IdentifierNode Scope CreateBinding \u8bed\u4e49\u5206\u6790\u65f6\uff0c\u83b7\u53d6\u4e86\u7c7b\u578b\u4fe1\u606f\u5c31\u76f4\u63a5\u5206\u914d\u5185\u5b58\u5e76\u751f\u6210\u7ed1\u5b9a\u5e76\u4f20\u9012\u7ed9IdentifierNode Binding\u6838\u5fc3\u529f\u80fd\u5c31\u662f\u63d0\u4f9b\u7c7b\u578b\u548c\u5185\u5b58\u5730\u5740 IdentifierNode\u662f\u53f6\u5b50\u7ed3\u70b9\uff0c\u6240\u4ee5\u4f7f\u7528visit\u3002\u8bed\u4e49\u5206\u6790\u8bbf\u95ee\u5c5e\u4e8eDeclarationNode\u7684\u6b64\u7ed3\u70b9\u65f6\u751f\u6210Binding\uff0c\u4ee3\u7801\u751f\u6210\u5668\u8bbf\u95ee\u65f6\u6b64\u7ed3\u70b9\u65f6\u751f\u6210\u5730\u5740\u3002 MemoryManager.java\u662f\u4e00\u4e2a\u5806\u7684\u5206\u914d\u5668\uff0c\u8fd9\u91cc\u7684\u51fd\u6570\u90fd\u4f7f\u7528\u5168\u5c40\u53d8\u91cf\uff0c\u56e0\u6b64\u4e0d\u80fd\u9012\u5f52\u8c03\u7528\u3002\u5176\u5b9e\u4e0e\u5176\u53eb\u5b83\u4eec\u51fd\u6570\uff0c\u4e0d\u5982\u53ebroutine/procedure\u66f4\u5408\u9002\uff0c\u56e0\u4e3a\u5b83\u4eec\u6ca1\u6709\u81ea\u5df1\u7684\u5c40\u90e8\u53d8\u91cf\u3002 \u51fd\u6570\u8c03\u7528\u5e94\u8be5\u751f\u6210\u4e00\u4e2a\u503c\uff0c\u5373\u4f7f\u8fd9\u4e2a\u51fd\u6570\u662fvoid\uff0c\u4ee3\u7801\u751f\u6210\u4e5f\u662f\u4e00\u4e2aValueCode AtomicExpression\u7b49\u540c\u4e8eC\u91cc\u7684PrimaryExpression\uff0c\u5373\u6700\u9ad8\u4f18\u5148\u7ea7\u7684\u8868\u8fbe\u5f0f\uff0c\u8868\u8fbe\u5f0f\u6700\u9ad8\u4f18\u5148\u7ea7\u603b\u662f\u4f1a\u6536\u655b\u5230\u6b64\u3002 \u9519\u8bef\u5904\u7406\uff0c\u8bed\u6cd5\uff0c\u8fd4\u56de\u4e00\u4e2aErrorNode\uff0c\u8bed\u4e49\u8d4b\u503c\u4e00\u4e2aErrorTYpe\uff0c\u4ee3\u7801\u751f\u6210\u62d2\u7edd\u3002 Bilby\u53ea\u6709\u5168\u5c40\uff08\u9759\u6001\uff09\u4f5c\u7528\u57df\uff0c\u51fd\u6570\u4f5c\u7528\u57df\uff0c\u53d8\u91cf\u5bfb\u5740\u5c31\u76f8\u5f53\u5bb9\u6613\u3002 \u6240\u6709\u7684string\u5b57\u9762\u91cf\u90fd\u53ef\u4ee5\u653e\u5728global\u4e0b\u3002 \u5de6\u503c\u4ee5\u5730\u5740\u7684\u5f62\u5f0f\u51fa\u73b0\u5728\u8d4b\u503c\u64cd\u4f5c\u5de6\u4fa7\uff0c\u5176\u4ed6\u5730\u65b9\u90fd\u8f6c\u6210\u6240\u5305\u542b\u7684\u6570\u503c\u3002 \u7b97\u7b26\u7684\u7c7b\u578b\u662f\u6240\u652f\u6301\u7684signature\u7684\u96c6\u5408\u3002 \u5982\u679c\u51fd\u6570\u652f\u6301\u91cd\u8f7d\uff0c\u90a3\u4e48\u5b83\u7684\u7c7b\u578b\u4e5f\u662fsignature\u7684\u96c6\u5408\uff0c\uff08\u5339\u914d\u53c2\u6570\u7684\u65f6\u5019\uff0c\u53ea\u5173\u5fc3\u53c2\u6570\u7c7b\u578b\uff0c\u6240\u4ee5\u4e0d\u540c\u7684\u8fd4\u56de\u7c7b\u578b\u4e0d\u80fd\u4f5c\u4e3a\u4e0d\u540csignature\u7684\u5224\u65ad\u4f9d\u636e\uff09","title":"\u4e00\u4e9b\u7b14\u8bb0\uff0c\u4ee5\u514d\u9057\u5fd8"},{"location":"ca.sfu.cmpt379.2022.fall/#_3","text":"\u5806\u5206\u914d\u5668\u7684\u8fd0\u884c\u65f6\u903b\u8f91","title":"\u4efb\u52a1\u5206\u89e3"},{"location":"ca.sfu.cmpt379.2022.fall/#_4","text":"a = 1 foo(): return a + 3 main(): a = 2 b = foo() if (b == 5) dynamic else if (b == 4) static","title":"\u5173\u4e8e\u52a8\u6001\u4f5c\u7528\u57df\u8ddf\u9759\u6001\u4f5c\u7528\u57df"},{"location":"ca.sfu.cmpt379.2022.fall/#design-patterns","text":"parseTree.PathToRootIterable","title":"Design Patterns"},{"location":"ca.sfu.cmpt379.2022.fall/#size-of-the-skeleton-project","text":"engineer@mac bilby-S % find . -name '*.java' | grep 'tests' -v | xargs wc -l | sort -hr 5876 total 785 ./src/asmCodeGenerator/runtime/MemoryManager.java 404 ./src/parser/Parser.java 319 ./src/asmCodeGenerator/ASMCodeGenerator.java 188 ./src/asmCodeGenerator/codeStorage/ASMCodeFragment.java 171 ./src/semanticAnalyzer/SemanticAnalysisVisitor.java 170 ./src/asmCodeGenerator/codeStorage/ASMOpcode.java 167 ./src/lexicalAnalyzer/LexicalAnalyzer.java 166 ./src/parseTree/ParseNode.java 158 ./src/asmCodeGenerator/codeStorage/ASMInstruction.java 124 ./src/symbolTable/Scope.java 121 ./src/parseTree/ParseTreePrinter.java 118 ./src/parseTree/ParseNodeVisitor.java 109 ./src/semanticAnalyzer/signatures/FunctionSignature.java 108 ./src/lexicalAnalyzer/PunctuatorScanningAids.java 105 ./src/asmCodeGenerator/Macros.java 96 ./src/semanticAnalyzer/signatures/FunctionSignatures.java 92 ./src/asmCodeGenerator/runtime/RunTime.java 91 ./src/applications/BilbyApplication.java 88 ./src/inputHandler/InputHandler.java 87 ./src/applications/BilbyCompiler.java 86 ./src/applications/BilbyCodeGenerator.java 85 ./src/inputHandler/LocatedCharStream.java 78 ./src/asmCodeGenerator/PrintStatementGenerator.java 77 ./src/parseTree/nodeTypes/IdentifierNode.java 77 ./src/inputHandler/LineBasedReader.java 68 ./src/symbolTable/SymbolTable.java 66 ./src/symbolTable/Binding.java 65 ./src/logging/BilbyLogger.java 62 ./src/inputHandler/LocatedChar.java 61 ./src/lexicalAnalyzer/PunctuatorScanner.java 61 ./src/inputHandler/TextLocation.java 59 ./src/symbolTable/MemoryLocation.java 58 ./src/symbolTable/NegativeMemoryAllocator.java 58 ./src/asmCodeGenerator/codeStorage/ASMCodeChunk.java 57 ./src/symbolTable/PositiveMemoryAllocator.java 56 ./src/lexicalAnalyzer/Punctuator.java 52 ./src/parseTree/nodeTypes/DeclarationNode.java 51 ./src/tokens/TokenImp.java 50 ./src/parseTree/nodeTypes/OperatorNode.java 49 ./src/lexicalAnalyzer/Keyword.java 49 ./src/inputHandler/PushbackCharStream.java 46 ./src/inputHandler/LocatedCharString.java 43 ./src/symbolTable/MemoryAccessMethod.java 43 ./src/applications/BilbyTokenPrinter.java 42 ./src/applications/BilbySemanticChecker.java 39 ./src/parseTree/PathToRootIterable.java 38 ./src/applications/BilbyAbstractSyntaxTree.java 36 ./src/parseTree/nodeTypes/BooleanConstantNode.java 36 ./src/applications/NumberedFileLister.java 35 ./src/parseTree/nodeTypes/IntegerConstantNode.java 35 ./src/lexicalAnalyzer/ScannerImp.java 33 ./src/tokens/LextantToken.java 33 ./src/parseTree/nodeTypes/PrintStatementNode.java 32 ./src/lexicalAnalyzer/PartiallyScannedPunctuator.java 31 ./src/tokens/Tokens.java 28 ./src/tokens/NumberToken.java 28 ./src/parseTree/nodeTypes/ProgramNode.java 28 ./src/parseTree/nodeTypes/MainBlockNode.java 27 ./src/semanticAnalyzer/types/PrimitiveType.java 25 ./src/lexicalAnalyzer/LexemeMap.java 23 ./src/parseTree/nodeTypes/SpaceNode.java 23 ./src/parseTree/nodeTypes/NewlineNode.java 23 ./src/parseTree/nodeTypes/ErrorNode.java 22 ./src/semanticAnalyzer/SemanticAnalyzer.java 21 ./src/asmCodeGenerator/Labeller.java 20 ./src/tokens/NullToken.java 20 ./src/tokens/IdentifierToken.java 17 ./src/semanticAnalyzer/types/Type.java 13 ./src/tokens/Token.java 11 ./src/symbolTable/MemoryAllocator.java 11 ./src/asmCodeGenerator/operators/SimpleCodeGenerator.java 9 ./src/lexicalAnalyzer/Scanner.java 8 ./src/lexicalAnalyzer/Lextant.java 5 ./src/inputHandler/Locator.java","title":"size of the skeleton project"},{"location":"certificate_verification/","text":"Assume we have certificate_1.pem signed by issuer with its private key issuer_private_key.pem When certificate_1.pem was created, pieces of information are filled into the request as the certificate to be signed. Then the issuer: verify the information in the request generate a hash of the tbsCertificate encrypt the using issuer's private key as the signature this signature is embedded into the signed certificate_1.pem So the verification simply goes in following steps: compute the hash of the tbsCertificate as hash_calculated pull the signature from the certificate openssl x509 -in certificate.pem -noout -text convert signature from 'FE:ED:..:10' to 0xfeed...10 as integer S pull the public key from the issuer's private key openssl rsa -in issuer_private_key.pem -pubout -out issuer_public_key.pem get the modulus and exponent(usually 65537) from the pubkey. openssl rsa -in issuer_public_key.pem -pubin -noout -text convert the modulus into integer M in the form of 0xffff...ff decrypt the signature using the issuer's public key as hash_expected get the last 40/64 characters from pow(S, 65537, M) according to your hash algorithms. compare hash_calculated with hash_expected","title":"Verify Cerfiticate"},{"location":"certificate_verification/#then-the-issuer","text":"verify the information in the request generate a hash of the tbsCertificate encrypt the using issuer's private key as the signature this signature is embedded into the signed certificate_1.pem","title":"Then the issuer:"},{"location":"certificate_verification/#so-the-verification-simply-goes-in-following-steps","text":"compute the hash of the tbsCertificate as hash_calculated pull the signature from the certificate openssl x509 -in certificate.pem -noout -text convert signature from 'FE:ED:..:10' to 0xfeed...10 as integer S pull the public key from the issuer's private key openssl rsa -in issuer_private_key.pem -pubout -out issuer_public_key.pem get the modulus and exponent(usually 65537) from the pubkey. openssl rsa -in issuer_public_key.pem -pubin -noout -text convert the modulus into integer M in the form of 0xffff...ff decrypt the signature using the issuer's public key as hash_expected get the last 40/64 characters from pow(S, 65537, M) according to your hash algorithms. compare hash_calculated with hash_expected","title":"So the verification simply goes in following steps:"},{"location":"hint/","text":"Check HTTP response heads. curl -I www.google.com","title":"hints"},{"location":"included/","text":"reference mkdocs.org Markdown Cheatsheet","title":"Included"},{"location":"included/#reference","text":"mkdocs.org Markdown Cheatsheet","title":"reference"},{"location":"java/","text":"basic Swing Application Template import javax.swing.JButton ; import javax.swing.JFrame ; import javax.swing.JLabel ; import javax.swing.JPanel ; import javax.swing.JOptionPane ; public final class DemoApp { public static void main ( String ... args ) { // JFrame\u4ee3\u8868\u57fa\u672c\u7a97\u53e3\uff0c\u63d0\u4f9b\u6807\u9898\uff0c\u7a97\u53e3\u5927\u5c0f JFrame frame = new JFrame ( \"title\" ); // \u9ed8\u8ba4\u7684\u5173\u95ed\u884c\u4e3a\u53ea\u662f\u9690\u85cf frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); // JPanel\u4ee3\u8868\u7ed8\u5236\u533a\u57df\uff0c\u6709\u4e00\u4e2a\u53cc\u7f13\u51b2\uff0c\u4e00\u4e2a\u57fa\u672c\u7684layout JPanel panel = new JPanel (); frame . getContentPane (). add ( panel ); panel . add ( new JLabel ( \"hello world!\" )); JButton button = new JButton ( \"OK\" ); panel . add ( button ); button . addActionListener ( event -> JOptionPane . showMessageDialog ( frame , \"message is here!\" )); // \u901a\u8fc7pack\u6765\u8ba1\u7b97\u7a97\u53e3\u7684\u5b9e\u9645\u5927\u5c0f frame . pack (); frame . setVisible ( true ); } }","title":"Java"},{"location":"java/#basic-swing-application-template","text":"import javax.swing.JButton ; import javax.swing.JFrame ; import javax.swing.JLabel ; import javax.swing.JPanel ; import javax.swing.JOptionPane ; public final class DemoApp { public static void main ( String ... args ) { // JFrame\u4ee3\u8868\u57fa\u672c\u7a97\u53e3\uff0c\u63d0\u4f9b\u6807\u9898\uff0c\u7a97\u53e3\u5927\u5c0f JFrame frame = new JFrame ( \"title\" ); // \u9ed8\u8ba4\u7684\u5173\u95ed\u884c\u4e3a\u53ea\u662f\u9690\u85cf frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ); // JPanel\u4ee3\u8868\u7ed8\u5236\u533a\u57df\uff0c\u6709\u4e00\u4e2a\u53cc\u7f13\u51b2\uff0c\u4e00\u4e2a\u57fa\u672c\u7684layout JPanel panel = new JPanel (); frame . getContentPane (). add ( panel ); panel . add ( new JLabel ( \"hello world!\" )); JButton button = new JButton ( \"OK\" ); panel . add ( button ); button . addActionListener ( event -> JOptionPane . showMessageDialog ( frame , \"message is here!\" )); // \u901a\u8fc7pack\u6765\u8ba1\u7b97\u7a97\u53e3\u7684\u5b9e\u9645\u5927\u5c0f frame . pack (); frame . setVisible ( true ); } }","title":"basic Swing Application Template"},{"location":"log/","text":"General Rule Note down exercises for EECS learning. Practice to keep the cache hot. Feeling \\(\\gt\\) Understanding bits and levels For \\(n\\) node complete tree the deeptest level is \\(\\lfloor log(n) \\rfloor\\) the left bottom node split the tree nodes \\(\\lceil log(n + 1) \\rceil = \\lfloor log(n) \\rfloor + 1\\) In a complete binary tree, for each node, let depth be the number of edges on the simple path from such node to the root node. Such that the depth of root node is \\(0\\) . And its direct children has depth of \\(1\\) . All the nodes of the same depth \\(x\\) , form the level of \\(x\\) . Let \\(L_i\\) denote the number of nodes in level \\(i\\) . It follows that \\(L_0 = 1\\) , \\(L_1 = 2\\) , and easily we can prove \\(L_n = 2^n\\) . Let \\(H_i\\) denote the number of all the nodes at and above level \\(i\\) . So we have \\[H_k = \\sum_{i = 0}^{k} L_i\\] Where \\(H_0 = L_0 = 1\\) , \\(H_1 = L_0 + L_1 = 3\\) . It is trivial to prove that \\[H_n = L_{n + 1} - 1\\] Some times we care about the property of a nearly complete binary tree with \\(n\\) nodes. Say, how many levels it covers? If we mark all the nodes using the topology order, top down, left to right. From \\(1\\) to \\(n\\) . Then we have the left bottom node \\(m = 2^L\\) where \\(L\\) is the deepest level of the tree. Since \\(m = 2^L \\leq n < 2^{L+1}\\) , it means \\(L \\leq log(n) < L+1\\) . So the lowest level is \\(L = \\lfloor log(n) \\rfloor\\) . And total level number is \\(L + 1 = \\lfloor log(n) \\rfloor + 1\\) since level index from \\(0\\) to \\(L\\) . Also, from \\[2^L \\leq n < 2^{L+1}\\] we have \\[ \\begin{array}{l} 2^L < n + 1 \\leq 2^{L+1} \\\\ L < log(n + 1) \\leq L+1 \\\\ \\lceil log(n + 1) \\rceil = L + 1 \\end{array} \\] So the total number of levels is \\[\\lceil log(n + 1) \\rceil = \\lfloor log(n) \\rfloor + 1\\] how many bits needed to represent a number \\(n \\in \\mathbb{N}\\) ? number binary #bits 0 0 1 1 1 1 2 10 2 3 11 2 4 100 3 5 101 3 6 110 3 7 111 3 8 1000 4 9 1001 4 \\[\\lceil log(n + 1) \\rceil\\] If a number \\(n\\) needs \\(k\\) bits to represent, then its binary string can be written as \\(1x_{k-1}\\ldots x_1\\) . Whenever we divide it by \\(2\\) , the binary string shift to right by one bit. After \\(k-1\\) times of shift, it turns out to be \\(1\\) . Apparently \\[2^{k-1} \\leq n < 2^k\\] So we have: \\( \\(k - 1 \\leq log(n) < k\\) \\) \\[k = \\lfloor log(n) \\rfloor + 1\\] Or: \\[k = \\lceil log(n+1) \\rceil\\] Since the binary string is actually the path from root to node n (index from 1). Bit string \\(1x_1x_2\\ldots x_{k-1}\\) . Root node means the leading \\(1\\) , for every level \\(i\\) , if \\(x_i\\) is \\(0\\) then go left, otherwise go right. Eventually you will reach node \\(n\\) at level \\(k-1\\) , including the leading \\(1\\) which represented by root node, there are \\(k\\) levels / bits involved. So, these two questions are equivalent: n nodes complete binary tree: how many levels n's binary format: how many bits reference mkdocs.org Markdown Cheatsheet","title":"Log"},{"location":"log/#general-rule","text":"Note down exercises for EECS learning. Practice to keep the cache hot.","title":"General Rule"},{"location":"log/#feeling-gt-understanding","text":"","title":"Feeling \\(\\gt\\) Understanding"},{"location":"log/#bits-and-levels","text":"For \\(n\\) node complete tree the deeptest level is \\(\\lfloor log(n) \\rfloor\\) the left bottom node split the tree nodes \\(\\lceil log(n + 1) \\rceil = \\lfloor log(n) \\rfloor + 1\\) In a complete binary tree, for each node, let depth be the number of edges on the simple path from such node to the root node. Such that the depth of root node is \\(0\\) . And its direct children has depth of \\(1\\) . All the nodes of the same depth \\(x\\) , form the level of \\(x\\) . Let \\(L_i\\) denote the number of nodes in level \\(i\\) . It follows that \\(L_0 = 1\\) , \\(L_1 = 2\\) , and easily we can prove \\(L_n = 2^n\\) . Let \\(H_i\\) denote the number of all the nodes at and above level \\(i\\) . So we have \\[H_k = \\sum_{i = 0}^{k} L_i\\] Where \\(H_0 = L_0 = 1\\) , \\(H_1 = L_0 + L_1 = 3\\) . It is trivial to prove that \\[H_n = L_{n + 1} - 1\\] Some times we care about the property of a nearly complete binary tree with \\(n\\) nodes. Say, how many levels it covers? If we mark all the nodes using the topology order, top down, left to right. From \\(1\\) to \\(n\\) . Then we have the left bottom node \\(m = 2^L\\) where \\(L\\) is the deepest level of the tree. Since \\(m = 2^L \\leq n < 2^{L+1}\\) , it means \\(L \\leq log(n) < L+1\\) . So the lowest level is \\(L = \\lfloor log(n) \\rfloor\\) . And total level number is \\(L + 1 = \\lfloor log(n) \\rfloor + 1\\) since level index from \\(0\\) to \\(L\\) . Also, from \\[2^L \\leq n < 2^{L+1}\\] we have \\[ \\begin{array}{l} 2^L < n + 1 \\leq 2^{L+1} \\\\ L < log(n + 1) \\leq L+1 \\\\ \\lceil log(n + 1) \\rceil = L + 1 \\end{array} \\] So the total number of levels is \\[\\lceil log(n + 1) \\rceil = \\lfloor log(n) \\rfloor + 1\\]","title":"bits and levels"},{"location":"log/#how-many-bits-needed-to-represent-a-number-n-in-mathbbn","text":"number binary #bits 0 0 1 1 1 1 2 10 2 3 11 2 4 100 3 5 101 3 6 110 3 7 111 3 8 1000 4 9 1001 4 \\[\\lceil log(n + 1) \\rceil\\] If a number \\(n\\) needs \\(k\\) bits to represent, then its binary string can be written as \\(1x_{k-1}\\ldots x_1\\) . Whenever we divide it by \\(2\\) , the binary string shift to right by one bit. After \\(k-1\\) times of shift, it turns out to be \\(1\\) . Apparently \\[2^{k-1} \\leq n < 2^k\\] So we have: \\( \\(k - 1 \\leq log(n) < k\\) \\) \\[k = \\lfloor log(n) \\rfloor + 1\\] Or: \\[k = \\lceil log(n+1) \\rceil\\] Since the binary string is actually the path from root to node n (index from 1). Bit string \\(1x_1x_2\\ldots x_{k-1}\\) . Root node means the leading \\(1\\) , for every level \\(i\\) , if \\(x_i\\) is \\(0\\) then go left, otherwise go right. Eventually you will reach node \\(n\\) at level \\(k-1\\) , including the leading \\(1\\) which represented by root node, there are \\(k\\) levels / bits involved. So, these two questions are equivalent: n nodes complete binary tree: how many levels n's binary format: how many bits","title":"how many bits needed to represent a number \\(n \\in \\mathbb{N}\\)?"},{"location":"log/#reference","text":"mkdocs.org Markdown Cheatsheet","title":"reference"},{"location":"re/","text":"Regular expression is a great tool to describe a computation structure Finite Automata . basic rule 1st try expression := term ('|' term) * term := factor (factor) * factor := element | element '*' element := literal | '(' expression ')' literal := one of printables except '(' ')' '|' '*' '\\' | escape escape := '\\' '(' | '\\' ')' | '\\' '|' | '\\' '\\' The problem of 1st try is that it does not address \\(\\epsilon\\) extensions expression := expression '|' term | term term := factor * factor := '(' expr ')' | exp exp := literal '*' literal := one of '_abcdefghijklmnopqrstuvwxyz0123456789' a b x","title":"Re"},{"location":"re/#basic-rule","text":"","title":"basic rule"},{"location":"re/#1st-try","text":"expression := term ('|' term) * term := factor (factor) * factor := element | element '*' element := literal | '(' expression ')' literal := one of printables except '(' ')' '|' '*' '\\' | escape escape := '\\' '(' | '\\' ')' | '\\' '|' | '\\' '\\' The problem of 1st try is that it does not address \\(\\epsilon\\)","title":"1st try"},{"location":"re/#extensions","text":"expression := expression '|' term | term term := factor * factor := '(' expr ')' | exp exp := literal '*' literal := one of '_abcdefghijklmnopqrstuvwxyz0123456789'","title":"extensions"},{"location":"re/#a","text":"","title":"a"},{"location":"re/#b","text":"","title":"b"},{"location":"re/#x","text":"","title":"x"},{"location":"rsa/","text":"do it manually to understand import math import subprocess cmd = ( 'openssl prime -generate -bits 512' ) prime = lambda : int ( subprocess . check_output ( cmd , shell = True ) . strip ()) p = prime () q = prime () N = p * q M = ( p - 1 ) * ( q - 1 ) # find e such that e coprime to M e = 65537 assert math . gcd ( e , M ) == 1 # find d such that e * d = 1 mod M, inverse of e mod M d = pow ( e , - 1 , M ) # x is the message to be encrypted x = 1234567890 # y is the encrypted message y = pow ( x , e , N ) print ( 'y =' , y ) # z is the decrypted message z = pow ( y , d , N ) print ( 'z =' , z ) # make sure z is the same as x assert x == z # e, d are exchangable for encryption and decryption y = pow ( x , d , N ) print ( 'y =' , y ) z = pow ( y , e , N ) print ( 'z =' , z ) assert x == z","title":"RSA"},{"location":"rsa/#do-it-manually-to-understand","text":"import math import subprocess cmd = ( 'openssl prime -generate -bits 512' ) prime = lambda : int ( subprocess . check_output ( cmd , shell = True ) . strip ()) p = prime () q = prime () N = p * q M = ( p - 1 ) * ( q - 1 ) # find e such that e coprime to M e = 65537 assert math . gcd ( e , M ) == 1 # find d such that e * d = 1 mod M, inverse of e mod M d = pow ( e , - 1 , M ) # x is the message to be encrypted x = 1234567890 # y is the encrypted message y = pow ( x , e , N ) print ( 'y =' , y ) # z is the decrypted message z = pow ( y , d , N ) print ( 'z =' , z ) # make sure z is the same as x assert x == z # e, d are exchangable for encryption and decryption y = pow ( x , d , N ) print ( 'y =' , y ) z = pow ( y , e , N ) print ( 'z =' , z ) assert x == z","title":"do it manually to understand"},{"location":"%E5%9B%BE/","text":"\u8868\u793a\u65b9\u6cd5 \u7ade\u8d5b\u5927\u4f6c\u4eec\u559c\u6b22\u7528\u7684\u94fe\u5f0f\u524d\u5411\u661f\uff0c\u672c\u8d28\u4e0a\u5176\u5b9e\u5c31\u662f\u90bb\u63a5\u8868\uff0c\u628a\u5404\u79cd\u4fe1\u606f\u62c6\u5206\u6210\u5355\u72ec\u7684\u6570\u7ec4\uff0c\u9ed8\u8ba4\u7528\u81ea\u7136\u6570\u8868\u793a\u5404\u4e2a\u8282\u70b9\u3002\u7528\u5728C\u8bed\u8a00\u5b9e\u73b0\u4e0a\u7684\u786e\u6709\u4e9b\u6709\u8da3\uff0c\u4e0d\u8fc7\u8fd9\u91cc\u7528python\u6211\u5c31\u76f4\u63a5\u6309CLRS\u7684\u65b9\u5f0f\u597d\u4e86\u3002 \\(\\forall e \\in G.E\\text{, } e \\text{ is undirected} \\equiv G \\text{ is undirected}\\) \u5c0f\u77e5\u8bc6 a.b \u53ef\u4ee5\u7528 b[a]\u6765\u5904\u7406\u3002","title":"\u56fe"},{"location":"%E5%9B%BE/#_1","text":"\u7ade\u8d5b\u5927\u4f6c\u4eec\u559c\u6b22\u7528\u7684\u94fe\u5f0f\u524d\u5411\u661f\uff0c\u672c\u8d28\u4e0a\u5176\u5b9e\u5c31\u662f\u90bb\u63a5\u8868\uff0c\u628a\u5404\u79cd\u4fe1\u606f\u62c6\u5206\u6210\u5355\u72ec\u7684\u6570\u7ec4\uff0c\u9ed8\u8ba4\u7528\u81ea\u7136\u6570\u8868\u793a\u5404\u4e2a\u8282\u70b9\u3002\u7528\u5728C\u8bed\u8a00\u5b9e\u73b0\u4e0a\u7684\u786e\u6709\u4e9b\u6709\u8da3\uff0c\u4e0d\u8fc7\u8fd9\u91cc\u7528python\u6211\u5c31\u76f4\u63a5\u6309CLRS\u7684\u65b9\u5f0f\u597d\u4e86\u3002 \\(\\forall e \\in G.E\\text{, } e \\text{ is undirected} \\equiv G \\text{ is undirected}\\)","title":"\u8868\u793a\u65b9\u6cd5"},{"location":"%E5%9B%BE/#_2","text":"a.b \u53ef\u4ee5\u7528 b[a]\u6765\u5904\u7406\u3002","title":"\u5c0f\u77e5\u8bc6"},{"location":"%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","text":"\u56de\u987e\u4e00\u4e0b\u4ec0\u4e48\u662f\u6392\u5e8f\u95ee\u9898\uff1f \u7ed9\u5b9a\u4e00\u4e2a\u5e8f\u5217 \\((a_1, a_2, a_3, \\ldots, a_n)\\) \uff0c\u4efb\u610f\u4e24\u4e2a\u5143\u7d20 \\(a_i\\) , \\(a_j\\) \u53ef\u4ee5\u6bd4\u8f83\u5927\u5c0f\uff0c\u6709\u5173\u7cfb \\(\\leq\\) \u5b58\u5728\uff0c\u4e14\u6b64\u5173\u7cfb\u6ee1\u8db3\u4f20\u9012\u6027\uff0c\u5373\uff1a \\(a_i \\leq a_j \\And a_j \\leq a_k \\implies a_i \\leq a_k\\) \u3002\u90a3\u4e48\u6392\u5e8f\u95ee\u9898\u5c31\u662f\u627e\u5230\u4e00\u4e2a\u7b97\u6cd5\uff0c\u901a\u8fc7\u6709\u9650\u6b21\u64cd\u4f5c\uff0c\u5f97\u5230\u539f\u6570\u7ec4\u7684\u4e00\u4e2a\u6392\u5217 \\((a'_1, a'_2, \\ldots, a'_n)\\) \uff0c\u6ee1\u8db3 \\(\\forall i \\in [1, n-1], a'_i \\leq a'_{i+1}\\) \u3002 \u4f18\u70b9 \u5f88\u597d\u5229\u7528\u4e86\u65f6\u7a7a\u5c40\u90e8\u6027 \u53ef\u5e76\u884c\u5904\u7406","title":"\u5feb\u901f\u6392\u5e8f"},{"location":"%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#_1","text":"\u7ed9\u5b9a\u4e00\u4e2a\u5e8f\u5217 \\((a_1, a_2, a_3, \\ldots, a_n)\\) \uff0c\u4efb\u610f\u4e24\u4e2a\u5143\u7d20 \\(a_i\\) , \\(a_j\\) \u53ef\u4ee5\u6bd4\u8f83\u5927\u5c0f\uff0c\u6709\u5173\u7cfb \\(\\leq\\) \u5b58\u5728\uff0c\u4e14\u6b64\u5173\u7cfb\u6ee1\u8db3\u4f20\u9012\u6027\uff0c\u5373\uff1a \\(a_i \\leq a_j \\And a_j \\leq a_k \\implies a_i \\leq a_k\\) \u3002\u90a3\u4e48\u6392\u5e8f\u95ee\u9898\u5c31\u662f\u627e\u5230\u4e00\u4e2a\u7b97\u6cd5\uff0c\u901a\u8fc7\u6709\u9650\u6b21\u64cd\u4f5c\uff0c\u5f97\u5230\u539f\u6570\u7ec4\u7684\u4e00\u4e2a\u6392\u5217 \\((a'_1, a'_2, \\ldots, a'_n)\\) \uff0c\u6ee1\u8db3 \\(\\forall i \\in [1, n-1], a'_i \\leq a'_{i+1}\\) \u3002","title":"\u56de\u987e\u4e00\u4e0b\u4ec0\u4e48\u662f\u6392\u5e8f\u95ee\u9898\uff1f"},{"location":"%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#_2","text":"\u5f88\u597d\u5229\u7528\u4e86\u65f6\u7a7a\u5c40\u90e8\u6027 \u53ef\u5e76\u884c\u5904\u7406","title":"\u4f18\u70b9"},{"location":"algorithms/asymptotic_analysis/","text":"Basic facts \\(logn \\in o(n^\\epsilon)\\) for any \\(\\epsilon > 0\\) \\(log^{c}n \\in o(n^\\epsilon)\\) for any \\(\\epsilon > 0\\) \\(c_1^{n} \\in o(c_2^{n})\\) for all \\(1 \\leq c_1 < c_2\\) order - \\(1/\\log n\\) - \\(2^{2+1/n}\\) - \\(\\sqrt{\\log \\log n}\\) - \\(\\log n/\\log \\log n\\) - \\(\\log n\\) - \\(\\Theta(\\log n) = 3^{\\log\\log n} < 3^{\\sqrt{\\log n}} < 3^{\\log n} = \\Theta(n)\\) \\(5(n+1/n)\\) \\(e^{\\ln n} = n\\) - \\(\\log (n!) = n \\log n\\) - \\(n \\log ^3 n\\) - \\(4n^{3/2}\\) - \\(4^{\\log n} = n^2\\) - \\(n^2 \\log n\\) - \\(n^3\\) - \\(n^{100}\\) - \\(3^{\\sqrt{n}}\\) - \\(4^{n} = 2^{2n}\\) - \\(n!\\) - \\(2^{n^2 \\log n} = n^{n^2}\\) \\(2^{2^n}\\)","title":"Big O"},{"location":"algorithms/asymptotic_analysis/#basic-facts","text":"\\(logn \\in o(n^\\epsilon)\\) for any \\(\\epsilon > 0\\) \\(log^{c}n \\in o(n^\\epsilon)\\) for any \\(\\epsilon > 0\\) \\(c_1^{n} \\in o(c_2^{n})\\) for all \\(1 \\leq c_1 < c_2\\)","title":"Basic facts"},{"location":"algorithms/asymptotic_analysis/#order","text":"","title":"order"},{"location":"algorithms/asymptotic_analysis/#-1log-n","text":"","title":"- \\(1/\\log n\\)"},{"location":"algorithms/asymptotic_analysis/#-221n","text":"","title":"- \\(2^{2+1/n}\\)"},{"location":"algorithms/asymptotic_analysis/#-sqrtlog-log-n","text":"","title":"- \\(\\sqrt{\\log \\log n}\\)"},{"location":"algorithms/asymptotic_analysis/#-log-nlog-log-n","text":"","title":"- \\(\\log n/\\log \\log n\\)"},{"location":"algorithms/asymptotic_analysis/#-log-n","text":"","title":"- \\(\\log n\\)"},{"location":"algorithms/asymptotic_analysis/#-thetalog-n-3loglog-n-3sqrtlog-n-3log-n-thetan","text":"\\(5(n+1/n)\\) \\(e^{\\ln n} = n\\)","title":"- \\(\\Theta(\\log n) = 3^{\\log\\log n} &lt; 3^{\\sqrt{\\log n}} &lt; 3^{\\log n} = \\Theta(n)\\)"},{"location":"algorithms/asymptotic_analysis/#-log-n-n-log-n","text":"","title":"- \\(\\log (n!) = n \\log n\\)"},{"location":"algorithms/asymptotic_analysis/#-n-log-3-n","text":"","title":"- \\(n \\log ^3 n\\)"},{"location":"algorithms/asymptotic_analysis/#-4n32","text":"","title":"- \\(4n^{3/2}\\)"},{"location":"algorithms/asymptotic_analysis/#-4log-n-n2","text":"","title":"- \\(4^{\\log n} = n^2\\)"},{"location":"algorithms/asymptotic_analysis/#-n2-log-n","text":"","title":"- \\(n^2 \\log n\\)"},{"location":"algorithms/asymptotic_analysis/#-n3","text":"","title":"- \\(n^3\\)"},{"location":"algorithms/asymptotic_analysis/#-n100","text":"","title":"- \\(n^{100}\\)"},{"location":"algorithms/asymptotic_analysis/#-3sqrtn","text":"","title":"- \\(3^{\\sqrt{n}}\\)"},{"location":"algorithms/asymptotic_analysis/#-4n-22n","text":"","title":"- \\(4^{n} = 2^{2n}\\)"},{"location":"algorithms/asymptotic_analysis/#-n","text":"","title":"- \\(n!\\)"},{"location":"algorithms/asymptotic_analysis/#-2n2-log-n-nn2","text":"\\(2^{2^n}\\)","title":"- \\(2^{n^2 \\log n} = n^{n^2}\\)"},{"location":"books/c_interfaces_and_implementations/","text":"C Interfaces and Implementations \u51b3\u5b9a\u6765\u7f8e\u56fd\u65f6\uff0c\u968f\u8eab\u5e26\u4e86\u51e0\u672c\u4e66\uff0c\u8fd9\u672c\u4e66\u662f\u5176\u4e2d\u4e4b\u4e00\u3002 \u6210\u90fd\u7684\u4e00\u4f4d\u540c\u4e8b\uff0c\u63a8\u8350\u8fc7\u8fd9\u672c\u4e66\uff0c\u53ef\u60dc\u6211\u4e70\u6765\u540e\uff0c\u56e0\u4e3a\u603b\u603b\u7f18\u6545\u6ca1\u80fd\u770b\u8fdb\u53bb\u3002\u4f46\u60f3\u7740\u4e5f\u8bb8\u6709\u4e00\u5929\u4f1a\u7406\u89e3\u8fd9\u672c\u4e66\u7684\u4ef7\u503c\uff0c\u4e8e\u662f\u643a\u5e26\u4e86\u6765\u3002 \u65f6\u81f3\u4eca\u65e5\uff0c\u8fc7\u4e86\u5feb\u5341\u5e74\uff0c\u6211\u603b\u7b97\u6162\u6162\u5f00\u59cb\u7406\u89e3\u5b83\u3002 #ifndef STACK_H #define STACK_H /* \u4e0d\u900f\u660e\u6307\u9488 */ /* \u4e0d\u900f\u9732\u5b9e\u73b0\u7ec6\u8282\u7ed9\u5ba2\u6237\u7a0b\u5e8f */ typedef struct stack_s * stack_t ; stack_t stack_new ( void ); bool stack_empty ( stack_t stack ); void stack_push ( stack_t stack , void * x ); void * stack_pop ( stack_t stack ); void stack_free ( stack_t * stack ); #endif list \u770b\u8d77\u6765\u4e00\u6837\u7684\u7ed3\u6784\uff0c\u5176\u5b9e\u5bf9\u94fe\u8868\u7ed3\u6784\u7684\u4e0d\u540c\u63cf\u8ff0\uff08\u5934\uff0c\u5269\u4e0b\u7684\u94fe\u8868\uff09\uff0c\u4ee5\u53ca\uff08\u5f53\u524d\u8282\u70b9\u503c\uff0c\u4e0b\u4e00\u4e2a\u8282\u70b9\uff09 struct list { void * head ; struct list * tail ; }; struct node { void * value ; struct node * next ; }","title":"C Interfaces and Implementations"},{"location":"books/c_interfaces_and_implementations/#c-interfaces-and-implementations","text":"\u51b3\u5b9a\u6765\u7f8e\u56fd\u65f6\uff0c\u968f\u8eab\u5e26\u4e86\u51e0\u672c\u4e66\uff0c\u8fd9\u672c\u4e66\u662f\u5176\u4e2d\u4e4b\u4e00\u3002 \u6210\u90fd\u7684\u4e00\u4f4d\u540c\u4e8b\uff0c\u63a8\u8350\u8fc7\u8fd9\u672c\u4e66\uff0c\u53ef\u60dc\u6211\u4e70\u6765\u540e\uff0c\u56e0\u4e3a\u603b\u603b\u7f18\u6545\u6ca1\u80fd\u770b\u8fdb\u53bb\u3002\u4f46\u60f3\u7740\u4e5f\u8bb8\u6709\u4e00\u5929\u4f1a\u7406\u89e3\u8fd9\u672c\u4e66\u7684\u4ef7\u503c\uff0c\u4e8e\u662f\u643a\u5e26\u4e86\u6765\u3002 \u65f6\u81f3\u4eca\u65e5\uff0c\u8fc7\u4e86\u5feb\u5341\u5e74\uff0c\u6211\u603b\u7b97\u6162\u6162\u5f00\u59cb\u7406\u89e3\u5b83\u3002 #ifndef STACK_H #define STACK_H /* \u4e0d\u900f\u660e\u6307\u9488 */ /* \u4e0d\u900f\u9732\u5b9e\u73b0\u7ec6\u8282\u7ed9\u5ba2\u6237\u7a0b\u5e8f */ typedef struct stack_s * stack_t ; stack_t stack_new ( void ); bool stack_empty ( stack_t stack ); void stack_push ( stack_t stack , void * x ); void * stack_pop ( stack_t stack ); void stack_free ( stack_t * stack ); #endif","title":"C Interfaces and Implementations"},{"location":"books/c_interfaces_and_implementations/#list","text":"\u770b\u8d77\u6765\u4e00\u6837\u7684\u7ed3\u6784\uff0c\u5176\u5b9e\u5bf9\u94fe\u8868\u7ed3\u6784\u7684\u4e0d\u540c\u63cf\u8ff0\uff08\u5934\uff0c\u5269\u4e0b\u7684\u94fe\u8868\uff09\uff0c\u4ee5\u53ca\uff08\u5f53\u524d\u8282\u70b9\u503c\uff0c\u4e0b\u4e00\u4e2a\u8282\u70b9\uff09 struct list { void * head ; struct list * tail ; }; struct node { void * value ; struct node * next ; }","title":"list"},{"location":"course/","text":"course plan","title":"Index"},{"location":"course/ucb.math.1a/","text":"math 1a - calculus \u5c5e\u4e8e\u5fae\u79ef\u5206\u7cfb\u5217\uff1amath1a/1b/53 \u5206\u6210\u4e09\u4e2a\u90e8\u5206\uff1a \u6559\u6750\u7b2c1\uff0c2\u7ae0\uff1a\u51fd\u6570\uff0c\u6781\u9650\uff0c\u5bfc\u6570 \u6559\u6750\u7b2c3\uff0c4\u7ae0\uff1a\u5fae\u5206\u53ca\u5176\u5e94\u7528 \u6559\u6750\u7b2c5\uff0c6\u7ae0\uff1a\u79ef\u5206\u53ca\u5176\u5e94\u7528 \u4e0a\u8ff0\u4e09\u90e8\u5206\u5185\u5bb9\u5927\u81f4\u5bf9\u5e94\u4e24\u6b21\u671f\u4e2d\u548c\u4e00\u6b21\u671f\u672b\u8003\u8bd5\u3002 Textbook: Stewart, Single Variable Calculus Outline of the Course: Chapter 1: Functions and Models 6 hours \uff08\u51fd\u6570\u548c\u6a21\u578b\uff09 Chapter 2: Limits and Derivatives 8 hours \uff08\u6781\u9650\u548c\u5bfc\u6570\uff09 Chapter 3: Differentiation Rules 8 hours \uff08\u5fae\u5206\u89c4\u5219\uff09 Chapter 4: Applications of Differentiation 8 hours \uff08\u5fae\u5206\u7684\u5e94\u7528\uff09 Chapter 5: Integrals 5 hours \uff08\u79ef\u5206\uff09 Chapter 6: Applications of Integration 3 hours \uff08\u79ef\u5206\u7684\u5e94\u7528\uff09 \u6309\u7167\u4f2f\u514b\u5229\u7684\u8bfe\u7a0b\u5b89\u6392\uff0c\u7c97\u7565\u4f30\u8ba1\u6bcf\u4e2a\u7ae0\u8282\u9700\u89818\u4e2a\u5c0f\u65f6\u8bfe\u5802\u8bb2\u5ea7\uff0c\u540c\u7b49\u65f6\u957f\u7684\u8ba8\u8bba\uff0c\u4ee5\u53ca\u56e0\u4eba\u800c\u5f02\u7684\u8bfe\u540e\u4f5c\u4e1a\u7ec3\u4e60\u65f6\u957f\u3002\u6bcf\u5929\u80fd\u62ff\u51fa\u67652\u4e2a\u5c0f\u65f6\u5b66\u4e60\u7684\u8bdd\uff0c\u6162\u6162\u5b662\u4e2a\u6708\u5e94\u8be5\u4e5f\u80fd\u5927\u81f4\u5b66\u5b8c\u3002 Prerequisites : Three and one-half years of high school math, including trigonometry \uff08\u4e09\u89d2\u5b66\uff09 and analytic geometry \uff08\u89e3\u6790\u51e0\u4f55\uff09 \u5b66\u4e60\u76ee\u6807 A thorough mastery of the material, including the main definitions the major theorems and their proofs as well as a demonstration of originality in solving problems writing proofs \u5b66\u4e60\u601d\u8def \u4e3b\u52a8\u601d\u8003\u6709\u54ea\u4e9b\u4ee3\u8868\u6027\u7684\u95ee\u9898\uff0c\u5c1d\u8bd5\u89e3\u51b3\uff0c\u770b\u770b\u522b\u4eba\u600e\u4e48\u89e3\u51b3\u7684 \u6709\u54ea\u4e9b\u7ed3\u8bba\uff0c\u8fd9\u4e9b\u7ed3\u8bba\u5982\u4f55\u505a\u51fa\u7684 events start: 2023-03-30 concepts: function limit derivative definitions theorems and proofs","title":"ucb.math.1a"},{"location":"course/ucb.math.1a/#_1","text":"A thorough mastery of the material, including the main definitions the major theorems and their proofs as well as a demonstration of originality in solving problems writing proofs","title":"\u5b66\u4e60\u76ee\u6807"},{"location":"course/ucb.math.1a/#_2","text":"\u4e3b\u52a8\u601d\u8003\u6709\u54ea\u4e9b\u4ee3\u8868\u6027\u7684\u95ee\u9898\uff0c\u5c1d\u8bd5\u89e3\u51b3\uff0c\u770b\u770b\u522b\u4eba\u600e\u4e48\u89e3\u51b3\u7684 \u6709\u54ea\u4e9b\u7ed3\u8bba\uff0c\u8fd9\u4e9b\u7ed3\u8bba\u5982\u4f55\u505a\u51fa\u7684","title":"\u5b66\u4e60\u601d\u8def"},{"location":"course/ucb.math.1a/#events","text":"start: 2023-03-30 concepts: function limit derivative definitions theorems and proofs","title":"events"},{"location":"data_structure/","text":"Basic Data Structures Basic Algorithms Toy Example hanoi hanoi.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def hanoi ( n ): ''' return moves as a list of tuples to move n pieces from pole1 to pole2 with help of pole3 >>> hanoi(0) >>> hanoi(1) [(1, 2)] >>> hanoi(2) [(1, 3), (1, 2), (3, 2)] ''' if n <= 0 : return None moves = [] def helper ( src , dst , temp , count ): if count == 1 : moves . append (( src , dst )) else : helper ( src , temp , dst , count - 1 ) moves . append (( src , dst )) helper ( temp , dst , src , count - 1 ) helper ( 1 , 2 , 3 , n ) return moves import doctest ; doctest . testmod () binary search bin_search.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def bin_search ( n , value ): ''' assume n is in order find the index of value in n otherwise return -1 >>> bin_search([], 1) -1 >>> bin_search([1], 1) 0 >>> bin_search([1], 2) -1 >>> bin_search([11,22,33], 11) 0 >>> bin_search([11,22,33], 22) 1 >>> bin_search([11,22,33], 33) 2 >>> bin_search([11,22,33], 10) -1 >>> bin_search([11,22,33], 20) -1 >>> bin_search([11,22,33], 40) -1 ''' low = 0 high = len ( n ) - 1 while low <= high : # (1) mid = ( low + high ) // 2 if value == n [ mid ]: return mid if value < n [ mid ]: high = mid - 1 else : low = mid + 1 return - 1 import doctest ; doctest . testmod () quick sort quick_sort.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def quick_sort ( data ): def _partition1 ( start , end ): ''' from CLRS: chapter 7 ''' pivot = data [ end ] i = start - 1 for j in range ( start , end ): if data [ j ] <= pivot : # (1) i += 1 data [ i ], data [ j ] = data [ j ], data [ i ] data [ end ], data [ i + 1 ] = data [ i + 1 ], data [ end ] return i + 1 def _partition2 ( start , end ): ''' from book: Problem Solving with Algorithms and Data Structures Using Python ''' assert start < end pivot = data [ start ] i = start + 1 j = end # loop invariant: # data on the left side of i are <= pivot # data on the right side of j are >= pivot while i <= j : while i <= j and data [ i ] <= pivot : i += 1 # (2) while i <= j and data [ j ] >= pivot : j -= 1 if i < j : data [ i ], data [ j ] = data [ j ], data [ i ] assert j < i # since pivot is at the begining, swap with j # if we have choosen pivot at the end, then swap with i data [ j ], data [ start ] = data [ start ], data [ j ] return j def _partition3 ( start , end ): ''' Another example using end pivot ''' pivot = data [ end ] i = start j = end - 1 while i <= j : while i <= j and data [ i ] <= pivot : i += 1 while i <= j and data [ j ] >= pivot : j -= 1 if i < j : data [ i ], data [ j ] = data [ j ], data [ i ] data [ i ], data [ end ] = data [ end ], data [ i ] return i def _partition4 ( start , end ): ''' my way ''' i = start for j in range ( start + 1 , end + 1 ): if data [ j ] < data [ start ]: i += 1 data [ i ], data [ j ] = data [ j ], data [ i ] data [ start ], data [ i ] = data [ i ], data [ start ] return i def _partition5 ( start , end ): ''' Hoare-partition ''' i = start pivot = data [ end ] for j in range ( start , end ): # loop invariant holds before each iteration assert all ( d < pivot for d in data [: i ]) if data [ j ] < pivot : data [ i ], data [ j ] = data [ j ], data [ i ] i += 1 # loop invariant holds after each iteration assert all ( d < pivot for d in data [: i ]) # now all items in data[start:end] are organized into two parts # from data[start:i] are < pivot # from data[i:end] are >= pivot # then we swap data[i] with data[end] # return i as the partition point data [ i ], data [ end ] = data [ end ], data [ i ] return i def _partition6 ( start , end ): ''' Hoare-partition variant, to save the last swap The cost is to protentially move more items unnecesary ''' i = start pivot = data [ end ] for j in range ( start , end + 1 ): # loop invariant holds before each iteration assert all ( d <= pivot for d in data [: i ]) if data [ j ] <= pivot : data [ i ], data [ j ] = data [ j ], data [ i ] i += 1 # loop invariant holds after each iteration assert all ( d <= pivot for d in data [: i ]) # now all items in data[start:end] are organized into two parts # from data[start:i] are <= pivot # data[i - 1] == pivot # from data[i+1:end] are > pivot return i - 1 _partition = _partition6 def _quick_sort ( start , end ): if start >= end : return p = _partition ( start , end ) _quick_sort ( start , p - 1 ) _quick_sort ( p + 1 , end ) _quick_sort ( 0 , len ( data ) - 1 ) def qsort ( data ): def _qsort ( begin , end ): if end - begin < 2 : return p = begin for i in range ( begin , end ): if data [ i ] <= data [ end - 1 ]: data [ p ], data [ i ] = data [ i ], data [ p ] p += 1 _qsort ( begin , p - 1 ) _qsort ( p , end ) return _qsort ( 0 , len ( data )) sort = qsort #sort = quick_sort def test_sort (): ''' >>> data = [2, 4, 6, 9, 7, 8, 5, 3, 1] >>> sort(data) >>> data [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> data = [] >>> sort(data) >>> data [] >>> data = [1] >>> sort(data) >>> data [1] >>> data = [1,2] >>> sort(data) >>> data [1, 2] >>> data = [1,2,3] >>> sort(data) >>> data [1, 2, 3] >>> data = [2,1] >>> sort(data) >>> data [1, 2] >>> data = [3,2,1] >>> sort(data) >>> data [1, 2, 3] ''' import doctest ; doctest . testmod () Insertion Sort Be careful not to swap the current one with the larger prior. Instead, move all the larger priors then insert the current one to its final place. \\(\\leq\\) is used in CLRS, yet I personally prefer to use \\(\\lt\\) to reduce unnecessary swap of multiple items with the same value. The difference is minor, either the last or the first one choose as the partition point. must be <= and >= to get meet","title":"main"},{"location":"data_structure/#basic-data-structures","text":"","title":"Basic Data Structures"},{"location":"data_structure/#basic-algorithms","text":"","title":"Basic Algorithms"},{"location":"data_structure/#toy-example","text":"","title":"Toy Example"},{"location":"data_structure/#hanoi","text":"hanoi.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def hanoi ( n ): ''' return moves as a list of tuples to move n pieces from pole1 to pole2 with help of pole3 >>> hanoi(0) >>> hanoi(1) [(1, 2)] >>> hanoi(2) [(1, 3), (1, 2), (3, 2)] ''' if n <= 0 : return None moves = [] def helper ( src , dst , temp , count ): if count == 1 : moves . append (( src , dst )) else : helper ( src , temp , dst , count - 1 ) moves . append (( src , dst )) helper ( temp , dst , src , count - 1 ) helper ( 1 , 2 , 3 , n ) return moves import doctest ; doctest . testmod ()","title":"hanoi"},{"location":"data_structure/#binary-search","text":"bin_search.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def bin_search ( n , value ): ''' assume n is in order find the index of value in n otherwise return -1 >>> bin_search([], 1) -1 >>> bin_search([1], 1) 0 >>> bin_search([1], 2) -1 >>> bin_search([11,22,33], 11) 0 >>> bin_search([11,22,33], 22) 1 >>> bin_search([11,22,33], 33) 2 >>> bin_search([11,22,33], 10) -1 >>> bin_search([11,22,33], 20) -1 >>> bin_search([11,22,33], 40) -1 ''' low = 0 high = len ( n ) - 1 while low <= high : # (1) mid = ( low + high ) // 2 if value == n [ mid ]: return mid if value < n [ mid ]: high = mid - 1 else : low = mid + 1 return - 1 import doctest ; doctest . testmod ()","title":"binary search"},{"location":"data_structure/#quick-sort","text":"quick_sort.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def quick_sort ( data ): def _partition1 ( start , end ): ''' from CLRS: chapter 7 ''' pivot = data [ end ] i = start - 1 for j in range ( start , end ): if data [ j ] <= pivot : # (1) i += 1 data [ i ], data [ j ] = data [ j ], data [ i ] data [ end ], data [ i + 1 ] = data [ i + 1 ], data [ end ] return i + 1 def _partition2 ( start , end ): ''' from book: Problem Solving with Algorithms and Data Structures Using Python ''' assert start < end pivot = data [ start ] i = start + 1 j = end # loop invariant: # data on the left side of i are <= pivot # data on the right side of j are >= pivot while i <= j : while i <= j and data [ i ] <= pivot : i += 1 # (2) while i <= j and data [ j ] >= pivot : j -= 1 if i < j : data [ i ], data [ j ] = data [ j ], data [ i ] assert j < i # since pivot is at the begining, swap with j # if we have choosen pivot at the end, then swap with i data [ j ], data [ start ] = data [ start ], data [ j ] return j def _partition3 ( start , end ): ''' Another example using end pivot ''' pivot = data [ end ] i = start j = end - 1 while i <= j : while i <= j and data [ i ] <= pivot : i += 1 while i <= j and data [ j ] >= pivot : j -= 1 if i < j : data [ i ], data [ j ] = data [ j ], data [ i ] data [ i ], data [ end ] = data [ end ], data [ i ] return i def _partition4 ( start , end ): ''' my way ''' i = start for j in range ( start + 1 , end + 1 ): if data [ j ] < data [ start ]: i += 1 data [ i ], data [ j ] = data [ j ], data [ i ] data [ start ], data [ i ] = data [ i ], data [ start ] return i def _partition5 ( start , end ): ''' Hoare-partition ''' i = start pivot = data [ end ] for j in range ( start , end ): # loop invariant holds before each iteration assert all ( d < pivot for d in data [: i ]) if data [ j ] < pivot : data [ i ], data [ j ] = data [ j ], data [ i ] i += 1 # loop invariant holds after each iteration assert all ( d < pivot for d in data [: i ]) # now all items in data[start:end] are organized into two parts # from data[start:i] are < pivot # from data[i:end] are >= pivot # then we swap data[i] with data[end] # return i as the partition point data [ i ], data [ end ] = data [ end ], data [ i ] return i def _partition6 ( start , end ): ''' Hoare-partition variant, to save the last swap The cost is to protentially move more items unnecesary ''' i = start pivot = data [ end ] for j in range ( start , end + 1 ): # loop invariant holds before each iteration assert all ( d <= pivot for d in data [: i ]) if data [ j ] <= pivot : data [ i ], data [ j ] = data [ j ], data [ i ] i += 1 # loop invariant holds after each iteration assert all ( d <= pivot for d in data [: i ]) # now all items in data[start:end] are organized into two parts # from data[start:i] are <= pivot # data[i - 1] == pivot # from data[i+1:end] are > pivot return i - 1 _partition = _partition6 def _quick_sort ( start , end ): if start >= end : return p = _partition ( start , end ) _quick_sort ( start , p - 1 ) _quick_sort ( p + 1 , end ) _quick_sort ( 0 , len ( data ) - 1 ) def qsort ( data ): def _qsort ( begin , end ): if end - begin < 2 : return p = begin for i in range ( begin , end ): if data [ i ] <= data [ end - 1 ]: data [ p ], data [ i ] = data [ i ], data [ p ] p += 1 _qsort ( begin , p - 1 ) _qsort ( p , end ) return _qsort ( 0 , len ( data )) sort = qsort #sort = quick_sort def test_sort (): ''' >>> data = [2, 4, 6, 9, 7, 8, 5, 3, 1] >>> sort(data) >>> data [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> data = [] >>> sort(data) >>> data [] >>> data = [1] >>> sort(data) >>> data [1] >>> data = [1,2] >>> sort(data) >>> data [1, 2] >>> data = [1,2,3] >>> sort(data) >>> data [1, 2, 3] >>> data = [2,1] >>> sort(data) >>> data [1, 2] >>> data = [3,2,1] >>> sort(data) >>> data [1, 2, 3] ''' import doctest ; doctest . testmod ()","title":"quick sort"},{"location":"data_structure/#insertion-sort","text":"Be careful not to swap the current one with the larger prior. Instead, move all the larger priors then insert the current one to its final place. \\(\\leq\\) is used in CLRS, yet I personally prefer to use \\(\\lt\\) to reduce unnecessary swap of multiple items with the same value. The difference is minor, either the last or the first one choose as the partition point. must be <= and >= to get meet","title":"Insertion Sort"},{"location":"data_structure/bst/","text":"Binary Search Tree Properties Property Description Root The only node does not have a parent. Height The number of edges from one node to its furthest decendent leave node. Depth The number of edges from one node to the root node. Level All the nodes with the same depth \\(x\\) form the level of \\(x\\) . Traverse Inorder # Code block content def inorder ( node , visit ): inorder ( node . left ) visit ( node . value ) inorder ( node . right ) bst_inorder.py 1 2 3 4 5 def inorder ( node , visit ): inorder ( node . left ) # comment visit ( node . value ) # (1) inorder ( node . right ) whatever Randomize a BST A simple solution: Traverse the BST and put elements into an array. Create a new empty BST. Randomly insert the array elements into the new BST. Tree Sort Use a BST to sort elements in a container. Create a BST. Put every element in the container into the BST. (deal with elements with same key to stablize the sort) Inorder traverse the BST and put the elements back into the container.","title":"BST"},{"location":"data_structure/bst/#binary-search-tree","text":"","title":"Binary Search Tree"},{"location":"data_structure/bst/#properties","text":"Property Description Root The only node does not have a parent. Height The number of edges from one node to its furthest decendent leave node. Depth The number of edges from one node to the root node. Level All the nodes with the same depth \\(x\\) form the level of \\(x\\) .","title":"Properties"},{"location":"data_structure/bst/#traverse","text":"","title":"Traverse"},{"location":"data_structure/bst/#inorder","text":"# Code block content def inorder ( node , visit ): inorder ( node . left ) visit ( node . value ) inorder ( node . right ) bst_inorder.py 1 2 3 4 5 def inorder ( node , visit ): inorder ( node . left ) # comment visit ( node . value ) # (1) inorder ( node . right ) whatever","title":"Inorder"},{"location":"data_structure/bst/#randomize-a-bst","text":"A simple solution: Traverse the BST and put elements into an array. Create a new empty BST. Randomly insert the array elements into the new BST.","title":"Randomize a BST"},{"location":"data_structure/bst/#tree-sort","text":"Use a BST to sort elements in a container. Create a BST. Put every element in the container into the BST. (deal with elements with same key to stablize the sort) Inorder traverse the BST and put the elements back into the container.","title":"Tree Sort"},{"location":"data_structure/graph/","text":"Graph simple graph: Graph does not have parallel edges or self-loops. simple path: vertices on the path are distinct. simple cycle: vertices on the cycle are distinct except the first and last one. A directed graph is acyclic if it has no directed cycles. \\(\\vec{G}\\) is strongly connected if for any two vertices \\(u\\) and \\(v\\) of \\(\\vec{G}\\) , \\(u\\) reaches \\(v\\) and \\(v\\) reaches \\(u\\) . Subgraph of a graph \\(G\\) is a graph \\(H\\) whose vertices and edges are subsets of the vertices and edges of \\(G\\) . A spanning subgraph of G is a subgraph of G that contains all the vertices of the graph G. If G is not connected, its maximal connected subgraphs are called the connected components of G. A forest is a graph without cycles. A tree is a connected forest, that is, a connected graph without cycles. A spanning tree of a graph is a spanning subgraph that is a tree. Strongly Connected Components from graph import G def test_scc (): g = G () g . add_direct ( 1 , 2 ) g . add_direct ( 2 , 3 ) g . add_direct ( 3 , 1 ) g . add_direct ( 1 , 4 ) g . add_direct ( 5 , 4 ) g . add_direct ( 4 , 5 ) assert g . timestamp () == { 1 : [ 1 , 10 ], 2 : [ 2 , 5 ], 3 : [ 3 , 4 ], 4 : [ 6 , 9 ], 5 : [ 7 , 8 ]} assert set ( g . scc ()) == set ([( 1 , 2 , 3 ), ( 4 , 5 )]) test_scc () graph implementation ''' G(V, E) adjacency-list: - representation for sparse graphs (E << V^2) adjacency-matrix: - representation for dense graphs (E ~ V^2) - or when we need quick answer of has_edge(v1, v2) Personally I prefer to use a map of map structure. ''' from stack import Stack class G : ''' a map of map structure representing edges as weight[u][v] ''' def __init__ ( self ): self . weights = {} @property def V ( self ): ''' return all vertices ''' vertices = set ( self . weights . keys ()) for d in self . weights . values (): vertices |= d . keys () return vertices @property def E ( self ): ''' return all edges ''' return [( u , v , self . weights [ u ][ v ]) for u in self . weights for v in self . weights [ u ]] def add_direct ( self , u , v ): self . weights . setdefault ( u , {})[ v ] = 1 def add_edge ( self , u , v ): self . add_direct ( u , v ) self . add_direct ( v , u ) def __str__ ( self ): ans = [] vertices = sorted ( self . V ) for u in vertices : line = [] for v in vertices : if u in self . weights and v in self . weights [ u ]: line . append ( str ( self . weights [ u ][ v ])) else : line . append ( '0' ) ans . append ( ', ' . join ( line )) return ' \\n ' . join ( ans ) def transpose ( self ): transpose = G () for u in self . weights : for v in self . weights [ u ]: transpose . add_direct ( v , u ) return transpose def timestamp ( self ): ''' DFS timestamp ''' visited = set () def dfs ( u ): nonlocal count if u in visited : return # found time visited . add ( u ) timestamp . setdefault ( u , [ 0 , 0 ])[ 0 ] = count count += 1 for v in self . weights . get ( u , []): dfs ( v ) # finish time timestamp [ u ][ 1 ] = count count += 1 timestamp = {} count = 1 for u in self . V : dfs ( u ) return timestamp def scc ( self ): def dfs ( u ): if u in visited : return # found time visited . add ( u ) for v in self . weights . get ( u , []): dfs ( v ) # finish time timestamp_stack . push ( u ) timestamp_stack = Stack () visited = set () for u in self . V : dfs ( u ) # DFS G.transpose to get SCCs def dfs2 ( u , scc , visited ): if u in visited : return visited . add ( u ) scc . add ( u ) for v in transpose . weights . get ( u , []): dfs2 ( v , scc , visited ) transpose = self . transpose () visited = set () for u in timestamp_stack : if u not in visited : scc = set () dfs2 ( u , scc , visited ) yield tuple ( scc )","title":"Graph"},{"location":"data_structure/graph/#graph","text":"simple graph: Graph does not have parallel edges or self-loops. simple path: vertices on the path are distinct. simple cycle: vertices on the cycle are distinct except the first and last one. A directed graph is acyclic if it has no directed cycles. \\(\\vec{G}\\) is strongly connected if for any two vertices \\(u\\) and \\(v\\) of \\(\\vec{G}\\) , \\(u\\) reaches \\(v\\) and \\(v\\) reaches \\(u\\) . Subgraph of a graph \\(G\\) is a graph \\(H\\) whose vertices and edges are subsets of the vertices and edges of \\(G\\) . A spanning subgraph of G is a subgraph of G that contains all the vertices of the graph G. If G is not connected, its maximal connected subgraphs are called the connected components of G. A forest is a graph without cycles. A tree is a connected forest, that is, a connected graph without cycles. A spanning tree of a graph is a spanning subgraph that is a tree.","title":"Graph"},{"location":"data_structure/graph/#strongly-connected-components","text":"from graph import G def test_scc (): g = G () g . add_direct ( 1 , 2 ) g . add_direct ( 2 , 3 ) g . add_direct ( 3 , 1 ) g . add_direct ( 1 , 4 ) g . add_direct ( 5 , 4 ) g . add_direct ( 4 , 5 ) assert g . timestamp () == { 1 : [ 1 , 10 ], 2 : [ 2 , 5 ], 3 : [ 3 , 4 ], 4 : [ 6 , 9 ], 5 : [ 7 , 8 ]} assert set ( g . scc ()) == set ([( 1 , 2 , 3 ), ( 4 , 5 )]) test_scc ()","title":"Strongly Connected Components"},{"location":"data_structure/graph/#graph-implementation","text":"''' G(V, E) adjacency-list: - representation for sparse graphs (E << V^2) adjacency-matrix: - representation for dense graphs (E ~ V^2) - or when we need quick answer of has_edge(v1, v2) Personally I prefer to use a map of map structure. ''' from stack import Stack class G : ''' a map of map structure representing edges as weight[u][v] ''' def __init__ ( self ): self . weights = {} @property def V ( self ): ''' return all vertices ''' vertices = set ( self . weights . keys ()) for d in self . weights . values (): vertices |= d . keys () return vertices @property def E ( self ): ''' return all edges ''' return [( u , v , self . weights [ u ][ v ]) for u in self . weights for v in self . weights [ u ]] def add_direct ( self , u , v ): self . weights . setdefault ( u , {})[ v ] = 1 def add_edge ( self , u , v ): self . add_direct ( u , v ) self . add_direct ( v , u ) def __str__ ( self ): ans = [] vertices = sorted ( self . V ) for u in vertices : line = [] for v in vertices : if u in self . weights and v in self . weights [ u ]: line . append ( str ( self . weights [ u ][ v ])) else : line . append ( '0' ) ans . append ( ', ' . join ( line )) return ' \\n ' . join ( ans ) def transpose ( self ): transpose = G () for u in self . weights : for v in self . weights [ u ]: transpose . add_direct ( v , u ) return transpose def timestamp ( self ): ''' DFS timestamp ''' visited = set () def dfs ( u ): nonlocal count if u in visited : return # found time visited . add ( u ) timestamp . setdefault ( u , [ 0 , 0 ])[ 0 ] = count count += 1 for v in self . weights . get ( u , []): dfs ( v ) # finish time timestamp [ u ][ 1 ] = count count += 1 timestamp = {} count = 1 for u in self . V : dfs ( u ) return timestamp def scc ( self ): def dfs ( u ): if u in visited : return # found time visited . add ( u ) for v in self . weights . get ( u , []): dfs ( v ) # finish time timestamp_stack . push ( u ) timestamp_stack = Stack () visited = set () for u in self . V : dfs ( u ) # DFS G.transpose to get SCCs def dfs2 ( u , scc , visited ): if u in visited : return visited . add ( u ) scc . add ( u ) for v in transpose . weights . get ( u , []): dfs2 ( v , scc , visited ) transpose = self . transpose () visited = set () for u in timestamp_stack : if u not in visited : scc = set () dfs2 ( u , scc , visited ) yield tuple ( scc )","title":"graph implementation"},{"location":"data_structure/hash/","text":"Hash Table Dictionary Interface A dictionary is an unordered container that contains key-value pairs, where keys are unique. Hash Table Hash Function Resolve Collision open addressing linear probing external chaining Load Factor","title":"Hash Table"},{"location":"data_structure/hash/#hash-table","text":"","title":"Hash Table"},{"location":"data_structure/hash/#dictionary-interface","text":"A dictionary is an unordered container that contains key-value pairs, where keys are unique.","title":"Dictionary Interface"},{"location":"data_structure/hash/#hash-table_1","text":"","title":"Hash Table"},{"location":"data_structure/hash/#hash-function","text":"","title":"Hash Function"},{"location":"data_structure/hash/#resolve-collision","text":"open addressing linear probing external chaining","title":"Resolve Collision"},{"location":"data_structure/hash/#load-factor","text":"","title":"Load Factor"},{"location":"data_structure/sa/","text":"suffix array def sa0 ( s ): ans = [ i for i in range ( len ( s ))] def qs ( begin , end ): if end - begin < 2 : return p = begin for i in range ( begin , end ): if s [ ans [ i ]:] <= s [ ans [ end - 1 ]:]: ans [ p ], ans [ i ] = ans [ i ], ans [ p ] p += 1 qs ( begin , p - 1 ) qs ( p , end ) qs ( 0 , len ( s )) return ans def sa1 ( s ): ans = [ i for i in range ( len ( s ))] ans . sort ( key = lambda i : s [ i :]) return ans def sa2 ( s ): return sorted (( i for i in range ( len ( s ))), key = lambda x : s [ x :]) sa = sa2 def test (): ''' >>> sa('ponoiiipoi') [9, 4, 5, 6, 2, 8, 3, 1, 7, 0] ''' import doctest ; doctest . testmod ()","title":"Suffix Array"},{"location":"data_structure/sa/#suffix-array","text":"def sa0 ( s ): ans = [ i for i in range ( len ( s ))] def qs ( begin , end ): if end - begin < 2 : return p = begin for i in range ( begin , end ): if s [ ans [ i ]:] <= s [ ans [ end - 1 ]:]: ans [ p ], ans [ i ] = ans [ i ], ans [ p ] p += 1 qs ( begin , p - 1 ) qs ( p , end ) qs ( 0 , len ( s )) return ans def sa1 ( s ): ans = [ i for i in range ( len ( s ))] ans . sort ( key = lambda i : s [ i :]) return ans def sa2 ( s ): return sorted (( i for i in range ( len ( s ))), key = lambda x : s [ x :]) sa = sa2 def test (): ''' >>> sa('ponoiiipoi') [9, 4, 5, 6, 2, 8, 3, 1, 7, 0] ''' import doctest ; doctest . testmod ()","title":"suffix array"},{"location":"data_structure/union_find/","text":"Union-Find Union-Find is also called disjoint set.","title":"Union-Find"},{"location":"data_structure/union_find/#union-find","text":"Union-Find is also called disjoint set.","title":"Union-Find"},{"location":"fpga/basic/","text":"We can view a computer as: I: a set of input values M: a set of memory values O: a set of output values F: a set of combinational functions, for each \\(o \\in O\\) , or \\(m \\in M\\) , there is a function \\(f: (I, M)\\) , so we have \\(F: (I, M) \\rightarrow (O, M)\\) to compute every \\(o\\) , and \\(m'\\) and there are two phases of operations: tick: load input values, load memory values: \\(I', M' \\rightarrow I, M\\) tock: compute output values, and next memory values: apply \\(F: (I, M) \\rightarrow (O, M')\\) So FPGA is used to allocate FFs to form the nodes, organize LUT to form the combination functions F, and wire them up to form the solution. FPGA Design Flow FPGA design is a hierarchical structure, starting from a top module with its inputs and outputs. // top_module.v module top_module ( input a , input b , output c ); // ... assign c = a & b ; endmodule To build the design, it takes some steps: design: functional requirements, performance requirements, and constraints, such as timing, power, area, etc. Decide the top module, and its inputs and outputs. HDL: write the Verilog code, which is a graph of modules and wires. synthesis: translate the Verilog code to a netlist, which is a graph of nodes and wires connecting gates. Some optimizations are applied. implementation: map the netlist to the FPGA, which is a graph of FFs and LUTs, RAMs, DSPs, etc. Physical placement and routing are applied. Timing analysis: check the timing constraints, and report the timing violations. Simulation: simulate the design, and check the simulation results. Programming: program the FPGA with the bitstream. For the code example above, we have the top module with two inputs and one output. Now we can synthesize and implement it, and get the bitstream file: using tcl (ticle) script to drive vivado: # impl.tcl # synthesis read_verilog - v top_module.v read_xdc constraints.xdc synth_design - top top_module - part xc7z020clg400-1 # implementation opt_design place_design phys_opt_design route_design write_bitstream - force top_module.bit Here we used the constraints file z1top.xdc to map the signals to the FPGA pins we use (pynq-z1 board). # constraints . xdc # Buttons set_property - dict { PACKAGE_PIN D19 IOSTANDARD LVCMOS33 } [ get_ports { a }]; set_property - dict { PACKAGE_PIN D20 IOSTANDARD LVCMOS33 } [ get_ports { b }]; # LEDs set_property - dict { PACKAGE_PIN R14 IOSTANDARD LVCMOS33 } [ get_ports { c }]; Run command: vivado -nolog -nojournal -mode batch -source impl.tcl Now it generates the bitstream file top_module.bit , which can be programmed to the FPGA. vivado -nolog -nojournal -mode batch -source program.tcl # program.tcl open_hw_manager connect_hw_server - url localhost:3121 current_hw_target [ get_hw_targets */ xilinx_tcf / Digilent /* ] set_property PARAM.FREQUENCY 15000000 [ get_hw_targets */ xilinx_tcf / Digilent /* ] open_hw_target current_hw_device [ get_hw_devices xc7z * ] set_property PROGRAM.FILE top_module.bit [ get_hw_devices xc7z * ] program_hw_devices [ get_hw_devices xc7z * ] refresh_hw_device [ get_hw_devices xc7z * ] close_hw_manager","title":"basic"},{"location":"fpga/basic/#fpga-design-flow","text":"FPGA design is a hierarchical structure, starting from a top module with its inputs and outputs. // top_module.v module top_module ( input a , input b , output c ); // ... assign c = a & b ; endmodule To build the design, it takes some steps: design: functional requirements, performance requirements, and constraints, such as timing, power, area, etc. Decide the top module, and its inputs and outputs. HDL: write the Verilog code, which is a graph of modules and wires. synthesis: translate the Verilog code to a netlist, which is a graph of nodes and wires connecting gates. Some optimizations are applied. implementation: map the netlist to the FPGA, which is a graph of FFs and LUTs, RAMs, DSPs, etc. Physical placement and routing are applied. Timing analysis: check the timing constraints, and report the timing violations. Simulation: simulate the design, and check the simulation results. Programming: program the FPGA with the bitstream. For the code example above, we have the top module with two inputs and one output. Now we can synthesize and implement it, and get the bitstream file: using tcl (ticle) script to drive vivado: # impl.tcl # synthesis read_verilog - v top_module.v read_xdc constraints.xdc synth_design - top top_module - part xc7z020clg400-1 # implementation opt_design place_design phys_opt_design route_design write_bitstream - force top_module.bit Here we used the constraints file z1top.xdc to map the signals to the FPGA pins we use (pynq-z1 board). # constraints . xdc # Buttons set_property - dict { PACKAGE_PIN D19 IOSTANDARD LVCMOS33 } [ get_ports { a }]; set_property - dict { PACKAGE_PIN D20 IOSTANDARD LVCMOS33 } [ get_ports { b }]; # LEDs set_property - dict { PACKAGE_PIN R14 IOSTANDARD LVCMOS33 } [ get_ports { c }]; Run command: vivado -nolog -nojournal -mode batch -source impl.tcl Now it generates the bitstream file top_module.bit , which can be programmed to the FPGA. vivado -nolog -nojournal -mode batch -source program.tcl # program.tcl open_hw_manager connect_hw_server - url localhost:3121 current_hw_target [ get_hw_targets */ xilinx_tcf / Digilent /* ] set_property PARAM.FREQUENCY 15000000 [ get_hw_targets */ xilinx_tcf / Digilent /* ] open_hw_target current_hw_device [ get_hw_devices xc7z * ] set_property PROGRAM.FILE top_module.bit [ get_hw_devices xc7z * ] program_hw_devices [ get_hw_devices xc7z * ] refresh_hw_device [ get_hw_devices xc7z * ] close_hw_manager","title":"FPGA Design Flow"},{"location":"mit_6.s081/","text":"MIT 6.S081 Introduction to Operating System and System Programming","title":"MIT S6.081"},{"location":"mit_6.s081/#mit-6s081","text":"Introduction to Operating System and System Programming","title":"MIT 6.S081"},{"location":"probability/","text":"Independency If we have: \\[P(A) \\cdot P(B) = P(A,B)\\] \\[P(A) = P(A|B)\\] We say that \\(A\\) is independent with \\(B\\) , as \\(A \\perp B\\) import random def sample (): a_done = False count = 0 while not a_done : a = random . random () < 0.5 count += 1 #print(a, b) if count == 1 : old_a = a else : if a != old_a : a_done = True return count n = 100000 print ( sum ( sample () for i in range ( n )) / n ) def sample (): a_done = False b_done = False count = 0 while not a_done or not b_done : a = random . random () < 0.5 b = random . random () < 0.5 count += 2 #print(a, b) if count == 2 : old_a = a old_b = b else : if a != old_a : a_done = True if b != old_b : b_done = True return count n = 1000000 print ( sum ( sample () for i in range ( n )) / n ) def sample (): a_done = False b_done = False count = 0 while not a_done and not b_done : a = random . random () < 0.5 b = random . random () < 0.5 count += 2 #print(a, b) if count == 2 : old_a = a old_b = b else : if a != old_a : a_done = True if b != old_b : b_done = True return count n = 1000000 print ( sum ( sample () for i in range ( n )) / n ) \\(|\\Omega| = 52 \\times 51 \\times 50 \\times 49 \\times 48\\) \\( \\(P[X=1] = 0\\) \\) 123456789abcd 11112 11122 11222 12222 \\[P[X=2] = \\frac{\\binom{52}{1} \\binom{51}{1} \\binom{50}{1} \\binom{49}{1} \\binom{48}{1} (2^5 - 2)}{\\frac{52!}{(52-5)!}}\\] ABCDE \\( \\(P[X=5] = \\frac{13 * 12 * 11 * 10 * 9 * 4^5}{52 * 51 * 50 * 49 * 48}\\) \\) ABCDA ABCDB ABCDC ABCDD \\[P[X=4] = \\frac{13*12*11*10*4*4^4}{52 * 51 * 50 * 49 * 48}\\] ABCAA ABCAB ABCAC ABCBA ABCBB ABCBC ABCCA ABCCB ABCCC \\( \\(P[X=3] = \\frac{13*12*11*3^2*4^4}{52 * 51 * 50 * 49 * 48}\\) \\)","title":"main"},{"location":"probability/#independency","text":"If we have: \\[P(A) \\cdot P(B) = P(A,B)\\] \\[P(A) = P(A|B)\\] We say that \\(A\\) is independent with \\(B\\) , as \\(A \\perp B\\) import random def sample (): a_done = False count = 0 while not a_done : a = random . random () < 0.5 count += 1 #print(a, b) if count == 1 : old_a = a else : if a != old_a : a_done = True return count n = 100000 print ( sum ( sample () for i in range ( n )) / n ) def sample (): a_done = False b_done = False count = 0 while not a_done or not b_done : a = random . random () < 0.5 b = random . random () < 0.5 count += 2 #print(a, b) if count == 2 : old_a = a old_b = b else : if a != old_a : a_done = True if b != old_b : b_done = True return count n = 1000000 print ( sum ( sample () for i in range ( n )) / n ) def sample (): a_done = False b_done = False count = 0 while not a_done and not b_done : a = random . random () < 0.5 b = random . random () < 0.5 count += 2 #print(a, b) if count == 2 : old_a = a old_b = b else : if a != old_a : a_done = True if b != old_b : b_done = True return count n = 1000000 print ( sum ( sample () for i in range ( n )) / n ) \\(|\\Omega| = 52 \\times 51 \\times 50 \\times 49 \\times 48\\) \\( \\(P[X=1] = 0\\) \\) 123456789abcd 11112 11122 11222 12222 \\[P[X=2] = \\frac{\\binom{52}{1} \\binom{51}{1} \\binom{50}{1} \\binom{49}{1} \\binom{48}{1} (2^5 - 2)}{\\frac{52!}{(52-5)!}}\\] ABCDE \\( \\(P[X=5] = \\frac{13 * 12 * 11 * 10 * 9 * 4^5}{52 * 51 * 50 * 49 * 48}\\) \\) ABCDA ABCDB ABCDC ABCDD \\[P[X=4] = \\frac{13*12*11*10*4*4^4}{52 * 51 * 50 * 49 * 48}\\] ABCAA ABCAB ABCAC ABCBA ABCBB ABCBC ABCCA ABCCB ABCCC \\( \\(P[X=3] = \\frac{13*12*11*3^2*4^4}{52 * 51 * 50 * 49 * 48}\\) \\)","title":"Independency"}]}